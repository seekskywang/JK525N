//==========================================================
//文件名称：User.c
//文件描述：菜单设置子程序
//文件版本：Ver1.0
//创建日期：2014.12.15
//修改日期：2015.09.06 11:15
//文件作者：
//备注说明：无
//注意事项：无
//==========================================================
#include <stdio.h>
#include <string.h>
//#include <stdlib.h>
#include <math.h>
////#include <absacc.h>
////#include <intrins.h>
#include "pbdata.h"
//#include <absacc.h>

#include "cpld.h"
//#include "GlobalValue.h"
//#include "Hardware.h"
#include "gpio.h"
#include "./RTC/bsp_rtc.h"
#include "./beep/bsp_beep.h" 
//#include "Interrupt.h"
//#include "Lcd240128.h"
//#include "Disp.h"
//#include "Keyboard.h"
//#include "Beep.h"
//#include "Isp.h"
//#include "Uart0.h"
//#include "Com.h"
//#include "User.h"
u8 usbreadtime[8];
u8 DispBuf[DISP_MAX_LEN];//显示缓冲区定义
//==========================================================
const u32 Port_Select[16][16]=//pos(x,y)x0-15 y0-15
{
    {0x00000000,0X10800000,0X10008000,0X01000080,0X14000000,0X10400000,0X10004000,0X10000040,
     0X12000000,0X10200000,0X10002000,0X10000020,0X11000000,0X10010000,0X10000100,0X10000001},
    {0X08020000,0x00000000,0X00028000,0X00020080,0X04020000,0X00420000,0X00024000,0X10000040,
     0X02020000,0X00220000,0X00022000,0X00020020,0X01020000,0X00030000,0X00020100,0X00020001},
    {0X08000200,0X00800200,0x00000000,0X00000280,0X04000200,0X00400200,0X00004200,0X00000240,
     0X02000200,0X00200200,0X00002200,0X00000220,0X01000200,0X00010200,0X00000300,0X00000201},
    {0X08000002,0X00800002,0X00008002,0x00000000,0X04000002,0X00400002,0X00004002,0X00000042,
     0X02000002,0X00200002,0X00002002,0X00000022,0X01000002,0X00010002,0X00000102,0X00000003},
    {0X28000000,0X20800000,0X20008000,0X20000080,0x00000000,0X20400000,0X20004000,0X20000040,
     0X22000000,0X20200000,0X20002000,0X20000020,0X21000000,0X20010000,0X20000100,0X20000001},
    {0X08040000,0X00840000,0X00048000,0X00040080,0X04040000,0x00000000,0X00044000,0X00040040,
     0X02040000,0X00240000,0X00042000,0X00040020,0X01040000,0X00050000,0X00040100,0X00040001},
    {0X08000400,0X00800400,0X00008400,0X00000480,0X04000400,0X00400400,0x00000000,0X00000440,
     0X02000400,0X00200400,0X00002400,0X00000420,0X01000400,0X00010400,0X00000500,0X00000401},
    {0X08000004,0X00800004,0X00008004,0X00000084,0X04000004,0X00400004,0X00004004,0x00000000,
     0X02000004,0X00200004,0X00002004,0X00000024,0X01000004,0X00010004,0X00000104,0X00000005},
    {0X48000000,0X40800000,0X40008000,0X40000080,0X44000000,0X40400000,0X40004000,0X40000040,
     0x00000000,0X40200000,0X40002000,0X40000020,0X41000000,0X40010000,0X40000100,0X40000001},
    {0X08080000,0X00880000,0X00088000,0X00080080,0X04080000,0X00480000,0X00084000,0X00080040,
     0X02080000,0X00000000,0X00082000,0X00080020,0X01080000,0X00090000,0X00080100,0X00080001},
    {0X08000800,0X00800800,0X00008800,0X00000880,0X04000800,0X00400800,0X00004800,0X00000840,
     0X02000800,0X00200800,0X00000000,0X00000820,0X01000800,0X00010800,0X00000900,0X00000801},
    {0X08000008,0X00800008,0X00008008,0X00000088,0X04000008,0X00400008,0X00004008,0X00000048,
     0X02000008,0X00200008,0X00002008,0X00000000,0X01000008,0X00010008,0X00000108,0X00000009},
    {0X88000000,0X80800000,0X80008000,0X80000080,0X84000000,0X80400000,0X80004000,0X80000040,
     0X82000000,0X80200000,0X80002000,0X80000020,0X00000000,0X80010000,0X80000100,0X80000001},
    {0X08100000,0X00900000,0X00108000,0X00100080,0X04100000,0X00500000,0X00104000,0X00100040,
     0X02100000,0X00300000,0X00102000,0X00100020,0X01100000,0X00000000,0X00100100,0X00100001},
    {0X08001000,0X00801000,0X00009000,0X00001080,0X04001000,0X00401000,0X00005000,0X00001040,
     0X02001000,0X00201000,0X00003000,0X00001020,0X01001000,0X00011000,0X00000000,0X00001001},
    {0X08000010,0X00800010,0X00008010,0X00000090,0X04000010,0X00400010,0X00004010,0X00000050,
     0X02000010,0X00200010,0X00002010,0X00000030,0X01000010,0X00010010,0X00000110,0X00000000}

};
const uint8_t User_Check_main[][12+1]=
{
	{"档号    "},
	{"标称值  "},
	{"参考值  "},

};
const uint8_t User_Check_Item[][12+1]=
{
  {"1.000mΩ"},
	{"10.00mΩ"},
	{"100.0mΩ"},
	{"1.000 Ω"},
	{"6.0000 V"},
	{"60.000 V"},

};
const uint8_t Test_Setitem[][9+1]=
{
	{"触   发:"},
	{"电阻上限:"},
	{"电阻下限:"},
	{"量   程:"},
	{"电压上限:"},
	{"电压下限:"},
};

const uint8_t Test_Setitem_E[][9+1]=
{
	{"TRIG  :"},
	{"R_HIGH:"},
	{"R_LOW :"},
	{"RANGE :"},
	{"V_HIGH:"},
	{"V_LOW :"},
};


const uint8_t All_TopName[][21+1]=
{
	{"< 测量显示 >"},
	{"< 档号显示 >"},
	{"< 档计数显示 >"},
	{"< 列表扫描显示 >"},
	{"< 测量设置 > "},
	{"< 用户校正 >"},
	{"< 极限列表设置 >"},
	{"< 列表扫描设置 >"},
	{"< 系统设置 >"},
	{"[ LCR文件列表 ]"},
	{"< 系统信息 >"},
	{"< 数据查看 >"},
};

const uint8_t All_TopName_E[][21+1]=
{
	{"< MEAS DISP > "},
	{"< 档号显示 >  "},
	{"< 档计数显示 >  "},
	{"< 列表扫描显示 >"},
	{"< MEAS SETUP >"},
	{"< 用户校正 >    "},
	{"< 极限列表设置 >"},
	{"< 列表扫描设置 >"},
	{"< SYS SETUP >"},
	{"[ LCR文件列表 ] "},
	{"< SYS DISP >"},

};

const uint8_t	Set_testitem[][9+1]=
{
	{"触   发:"},
	{"速   度:"},
	{"         "},
	{"电阻比较:"},
	{"电阻下限:"},
	{"         "},
	{"电压比较:"},
	{"电压下限:"},
	{"        "},
	
	{"量   程:"},
	{"讯   响:"},
	{"         "},
	{"电阻标称:"},
	{"电阻上限:"},
	
	{"         "},
	{"电压标称:"},
	{"电压上限:"} ,
	{"         "},
};
const uint8_t	Set_testitem_E[][9+1]=
{
	{"TRIG  :"},
	{"SPEED :"},
	{"        "},
	{"R_COMP:"},
	{"R_LOW :"},
	{"        "},
	{"V_COMP:"},
	{"V_LOW :"},
	{"      "},
	
	{"RANGE :"},
	{"BEEP  :"},
	{"       "},
	{"R_NORM:"},
	{"R_HIGH:"},
	
	{"       "},
	{"V_NORM:"},
	{"V_HIGH:"} ,
	{"       "},
};
const uint8_t Test_Tirpvalue[][6+1]=
{
	{"自动"},
	{"手动"}

};
const uint8_t Test_Tirpvalue_E[][6+1]=
{
	{"AUTO"},
	{"MAN"}

};
const uint8_t Test_Speedvalue[][6+1]=
{
	{"慢速"},
	{"中速"},
  {"快速"},
  {"极速"}

};
const uint8_t Test_Speedvalue_E[][6+1]=
{
	{"SLOW"},
	{"MED"},
  {"FAST"},
  {"TOP"}

};
const uint8_t Test_Compvalue[][6+1]=
{
	{"关闭"},
	{"打开"}

};
const uint8_t Test_Compvalue_E[][6+1]=
{
	{"CLOSE"},
	{"OPEN"}

};

const uint8_t Setup_Beep[][6+1]=
{
	"关闭  ",
	"合格  ",
	"不合格",

};
const uint8_t Setup_Beep_E[][6+1]=
{
	"CLOSE",
	"PASS ",
	"FAIL ",

};
const uint8_t INPUT[][7]={"输入"};
const uint8_t INPUT_E[][7]={"INPUT"};
    

const uint8_t User_Range[][10+1]=
{
    {"自动"},
    {"3 mΩ"},
    {"30 mΩ"},
    {"300 mΩ"},
    {"3 Ω"},
    {"100 Ω"},
    {"1k Ω"},
    {"10k Ω"},

};
const uint8_t User_Range_E[][10+1]=
{
    {"AUTO"},
    {"3 mΩ"},
    {"30 mΩ"},
    {"300 mΩ"},
    {"3 Ω"},
    {"100 Ω"},
    {"1k  Ω"},
    {"10k Ω"},
    

};
const u8 DISP_UINT[][4]=
{
    {"mΩ"},
    {"Ω"},
    {"kΩ"}

};
const uint8_t User_Rangeset[][11]=
{
    {"AUTO"},
    {"HAND"},
    {"NORMAL"},
    {"INCR+"},
    {"DECR-"},
    
};
const uint8_t Sys_Setitem[][10+1]=
{
	{"串口开关:"},
	{"波特率 :"},
	{"U盘开关:"},
	{"I/O口 :"},
	{"显示语言:"},
	
	{"日   期:"},
    {"时   间:"},
    {"文件名称:"},
	
};

const uint8_t HIS_TOP[][10+1]=
{
	{"时间"},
	{"电阻"},
	{"电压"},
	{"分选"},

	
};

const uint8_t Sys_Setitem_E[][10+1]=
{
	{"SERIAL:"},
	{"BAUD  :"},
	{"U_DISK:"},
	{"I/O_PORT:"},
	{"LANGUAGE:"},
	
	{"DATE:"},
    {"TIME:"},
    {"FILE:"},
	
};

const uint8_t Sys_Buard_Value[][6+1]=
{
	{"2400"},
	{"4800"},
	{"9600"},
	{"14400"},
	{"19200"},
	{"38400"},
	{"56000"},
	{"115200"},

};
const uint8_t Sys_Language_Value[][7+1]=
{
	{"中文"},
	{"ENGLISH"}

};

const uint8_t Sys_Language_Button[][7+1]=
{
	{"中文"},
	{"ENG"}

};

const uint8_t BiasButton_Tip[][7+1]=  //频率选择时候的下面的提示符号
{
    {"DECR -"},
    {"INCR +"},

};

const uint8_t Sys_Sys[][20+1]=
{
	{"仪器型号:  JK625  "},
	{"软件版本:  Ver:2.1"},
	{"硬件版本:  Ver:1.0"},
	{"仪器编号:"},

};
//1.3修改校准数据存到内部flash
//1.4修改设置数据存到内部flash
//1.5修改手动触发只存一次数据
//1.9增加数据保持和sd卡存储数据查看功能
//2.0优化掉数据，增加显示小数点位数选择
//2.1优化掉设置数据
const uint8_t Sys_Sys_E[][20+1]=
{
	{"INST MODEL:  JK625 "},
	{"SOFT VER:   Ver:2.1"},
	{"HARD VER:   Ver:1.0"},
	{"SERIALNO:"},	

};
const uint8_t Range_Disp_Test[][7][11+1]=
{
    {
        {"AUTO  3mΩ"},
        {"AUTO 30mΩ"},
        {"AUTO300mΩ"},
        {"AUTO   3Ω"},
        {"AUTO 100Ω"},
        {"AUTO  1kΩ"},
        {"AUTO 10kΩ"},
       
    },
    {
        {"HAND  3mΩ"},
        {"HAND 30mΩ"},
        {"HAND300mΩ"},
        {"HAND   3Ω"},
        {"HAND 100Ω"},
        {"HAND  1kΩ"},
        {"HAND 10kΩ"},
       
    }


};
const u8 RANG_4094[8]={0x48,0x48,0x48,0x80,0x01,0x01,0x02,0x04};//换挡的时候的4094的值
//位操作增减数值
const u16 POW_NUM[4]=
{
	1000,
	100,
	10,
	1,
};
const u32 RANGE_RATE[5]=
{
	1000,
	10000,
	100000,
	1000000,
	10000000,

};
const vu32 Debug_Compvalue[][2]=
{
	{800,1200},
	{800,1200},
	{800,1200},
	{800,1200},

	{50000,80000},
	{50000,80000}

};
const vu32 Debug_Compvaluemind[]=
{
	10000,10000,10000,10000,10000,10000,60000,60000


};
#define FACTORY_MENU_MAX (sizeof(FactoryTab)/sizeof(FactoryTab[0])-1)
    Test_ValueTypedef Test_Value;

Test_ValueTypedef Test_Value_V;
//==========================================================
//设置菜单

//==========================================================
//确认提示

//==========================================================
//数值提示

//==========================================================
//选择提示

//==========================================================
//参数菜单

//==========================================================
//编号

//==========================================================
//系统菜单

//==========================================================
//系统项上、下限
const u16 SystemLimit[][2]=
{
	{500, 1},
	{9999, 0},
	{9999, 0},
	{9999, 0},
};
//==========================================================
//系统项上、下限
const u16 SystemLimitDot[5]=
{
	0,1,0,0
	
};
//==========================================================
//参数项上、下限
const u8 ParameterLimit[][2]=
{
	{ RANGE_MAX, 0},//量程模式
	{ 2, 0},//速度
	{ 255, 1},//平均次数
	{ 1, 0},//扫描次数
	{ 3, 0},//测试模式
    { 14, 0},//温度通道选择
};
const float Debug_Limit[2]={1.9,0.7};
//==========================================================
//系统状态


//==========================================================
//出厂信息

//==========================================================

//==========================================================
//参数菜单项
enum ParameterMenuEnum
{	
	PARAMETER_MENU_RANGE ,
	PARAMETER_MENU_BEEP ,
	PARAMETER_MENU_CLEAR ,
	PARAMETER_MENU_TRIG ,
	PARAMETER_MENU_UART ,
};

//==========================================================
//系统菜单项
enum SYSTEMMenuEnum
{	
	SYSTEM_MENU_VOUT ,
	SYSTEM_MENU_Ttime,
	SYSTEM_MENU_RH	 ,
	SYSTEM_MENU_RL	 ,
	
};
//==========================================================
//函数名称：InitGlobalValue
//函数功能：初始化全局变量
//入口参数：无
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 15:33
//备注说明：无
//==========================================================
void InitGlobalValue(void)
{
	u8 len;
	u8 * buf;
						 
	buf=(u8 *)&Jk516save;//数据首地址
	len=(u8)sizeof(Jk516save_TypeDef);
	while(len--)
	{
		*buf=0;//清空
		buf++;
	}
	F_Password=FALSE;//密码有效标志	
}

//==========================================================
//函数名称：Parameter_valuecomp
//函数功能：初始化值得比较
//入口参数：无
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 15:33
//备注说明：无
//==========================================================
void Parameter_valuecomp(void)
{
	  u8 i;
    if(Jk516save.Set_Data.trip>2)
        Jk516save.Set_Data.trip=0;
    if(Jk516save.Set_Data.speed>3)
        Jk516save.Set_Data.speed=0;
    if(Jk516save.Set_Data.Res_comp>1)
        Jk516save.Set_Data.Res_comp=0;
    if(Jk516save.Set_Data.V_low.Dot>5)
        Jk516save.Set_Data.V_low.Dot=3;
    if(Jk516save.Set_Data.V_low.Num>600000)
        Jk516save.Set_Data.V_low.Num=60000;
    if(Jk516save.Set_Data.V_low.Unit>5)
        Jk516save.Set_Data.V_low.Unit=0;
    if(Jk516save.Set_Data.Range>10)
        Jk516save.Set_Data.Range=0;
    if(Jk516save.Set_Data.Range_Set>10)
        Jk516save.Set_Data.Range_Set=0;
    if(Jk516save.Set_Data.beep>3)
        Jk516save.Set_Data.beep=0;
    if(Jk516save.Set_Data.V_comp>1)
        Jk516save.Set_Data.V_comp=0;
    
    if(Jk516save.Set_Data.Nominal_Res.Dot>5)
        Jk516save.Set_Data.Nominal_Res.Dot=3;
    if(Jk516save.Set_Data.Nominal_Res.Num>3000000)
        Jk516save.Set_Data.Nominal_Res.Num=300000;
    if(Jk516save.Set_Data.Nominal_Res.Unit>5)
        Jk516save.Set_Data.Nominal_Res.Unit=0;
    
    if(Jk516save.Set_Data.High_Res.Dot>5)
        Jk516save.Set_Data.High_Res.Dot=3;
    if(Jk516save.Set_Data.High_Res.Num>3000000)
        Jk516save.Set_Data.High_Res.Num=3000000;
    if(Jk516save.Set_Data.High_Res.Unit>5)
        Jk516save.Set_Data.High_Res.Unit=0;
    
    if(Jk516save.Set_Data.Res_low.Dot>5)
        Jk516save.Set_Data.Res_low.Dot=3;
    if(Jk516save.Set_Data.Res_low.Num>300000)
        Jk516save.Set_Data.Res_low.Num=300000;
    if(Jk516save.Set_Data.Res_low.Unit>5)
        Jk516save.Set_Data.Res_low.Unit=0;
    
    if(Jk516save.Set_Data.Nominal_V.Dot>5)
        Jk516save.Set_Data.Nominal_V.Dot=3;
    if(Jk516save.Set_Data.Nominal_V.Num>600000)
        Jk516save.Set_Data.Nominal_V.Num=60000;
    if(Jk516save.Set_Data.Nominal_V.Unit>5)
        Jk516save.Set_Data.Nominal_V.Unit=0;
    
    
    
    if(Jk516save.Set_Data.V_high.Dot>5)
        Jk516save.Set_Data.V_high.Dot=3;
    if(Jk516save.Set_Data.V_high.Num>600000)
        Jk516save.Set_Data.V_high.Num=60000;
    if(Jk516save.Set_Data.V_high.Unit>5)
        Jk516save.Set_Data.V_high.Unit=0;
    
    if(Jk516save.Sys_Setvalue.buard>10)
        Jk516save.Sys_Setvalue.buard=0;
    if(Jk516save.Sys_Setvalue.lanage>1)
        Jk516save.Sys_Setvalue.lanage=0;
    if(Jk516save.Sys_Setvalue.plc>1)
        Jk516save.Sys_Setvalue.plc=0;
    if(Jk516save.Sys_Setvalue.uart>1)
        Jk516save.Sys_Setvalue.uart=0;
    if(Jk516save.Sys_Setvalue.u_flag>1)
        Jk516save.Sys_Setvalue.u_flag=0;
	if(Jk516save.dispdot>1)
        Jk516save.dispdot=0;
    for(i=0;i<20;i++)
    {
        if(Jk516save.Sys_Setvalue.textname[i]>128)
            Jk516save.Sys_Setvalue.textname[i]=0;
            
    
    }
    for(i=0;i<10;i++)
    {
        if(Jk516save.fac_num[i]>128)
        {
            if(i<8)
                Jk516save.fac_num[i]='0';
            else
                Jk516save.fac_num[i]=0;
                
        }
    
    }
    
//    for(i=0;i<RANGE_MAX+2;i++)
//    {
//        if((Jk516cal.Debug_Value[i].ad_value>Debug_Limit[0]))
//            Jk516cal.Debug_Value[i].ad_value=1;
//        if((Jk516cal.Debug_Value[i].standard>Debug_Compvalue[i][0])||(Jk516cal.Debug_Value[i].standard<Debug_Compvalue[i][1]))
//            Jk516cal.Debug_Value[i].standard=Debug_Compvaluemind[i];
//        if(i<RANGE_MAX)
//        {
//            if(Jk516save.Clear[i]>=10000)
//                Jk516save.Clear[i]=0;
//        
//        }
//        else
//        {
//            if(Jk516save.Clear_V[i-RANGE_MAX]>=500000)
//                Jk516save.Clear_V[i-RANGE_MAX]=0;
//        }       
//    }

}
//==========================================================
//函数名称：Hex_Format
//函数功能：格式化整数值到DispBuf
//入口参数：整数，小数位数，数值位数，显示零
//出口参数：无
//创建日期：2014.12.15
//修改日期：2015.01.14 13:12
//备注说明：dot=0-XXXXX XXXX.X XXX.XX XX.XXX X.XXXX-Dot=4
//注意事项：最多5位数
//==========================================================
void Hex_Format(u32 dat , u8 Dot , u8 len , u8 dispzero)
{
	u8 i,j;

	if(len>8)len=8;//最大长度8
	if(len==0)len=1;
	if(Dot>7)Dot=7;//最大小数点7
	if(Dot>len)Dot=len;

	for(i=0;i<sizeof(DispBuf);i++)	//清空缓冲区
		DispBuf[i]=' ';

	for(i=len;i>0;i--)	//数制转换
	{
		DispBuf[i-1] = dat%10 + '0';//转为ASCII
		dat/=10;
	}
	
	if(Dot)//有小数点
	{
		j=len;
		i=Dot;//取小数点位置
		while(i--)
		{
			DispBuf[j]=DispBuf[j-1];
			j--;
		}
		DispBuf[j]='.';//加入小数点
	}

	if(dispzero==FALSE)//不显示无效零
	{
		for(i=0;i<(len-1);i++)
		{
			if((DispBuf[i]=='0')&&(DispBuf[i+1]!='.'))
				DispBuf[i]=' ';
			else
				break;
		}
	}
	if(Dot)len++;
	for(i=len;i<sizeof(DispBuf);i++)//末尾补结束符'\0'
	{
		DispBuf[i]=0;
	}			
}
//==========================================================
//函数名称：Disp_Product_Model
//函数功能：显示产品型号
//入口参数：无
//出口参数：无
//创建日期：2015.10.27
//修改日期：2015.10.27 16:00
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_Software_Version
//函数功能：显示软件版本
//入口参数：无
//出口参数：无
//创建日期：2015.10.27
//修改日期：2015.10.27 16:00
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Compile_Date
//函数功能：显示编译日期
//入口参数：无
//出口参数：无
//创建日期：2015.10.27
//修改日期：2015.10.27 16:00
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_PowerOn_Menu
//函数功能：显示开机界面
//入口参数：无
//出口参数：无
//创建日期：2015.10.26
//修改日期：2015.10.26 15:00
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Number_Setup
//函数功能：数值框设置处理
//入口参数：NumBox_TypeDef
//出口参数：键值
//创建日期：2015.01.07
//修改日期：2015.08.19 13:53
//备注说明：无
//==========================================================

//==========================================================
//函数名称：ListBox_Setup
//函数功能：列表框设置
//入口参数：无
//出口参数：键值
//创建日期：2015.01.08
//修改日期：2015.08.19 13:48
//备注说明：列表项标题长度固定为8个字符
//==========================================================


//==========================================================
//函数名称：Disp_Frame
//函数功能：显示界面框架
//入口参数：无
//出口参数：无
//创建日期：2014.12.26
//修改日期：2015.08.18 16:30
//备注说明：整屏更新
//==========================================================

//==========================================================
//函数名称：Disp_Boot_Number
//函数功能：显示开机次数
//入口参数：无
//出口参数：无
//创建日期：2014.11.13
//修改日期：2014.11.13 12:42
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Software_Version
//函数功能：显示软件版本
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.01.09 15:13
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Hardware_Version
//函数功能：显示硬件版本
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.01.09 15:13
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Compile_Date
//函数功能：显示编译日期
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.01.09 15:13
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Product_Model
//函数功能：显示产品型号
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.01.09 15:13
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Company_Name
//函数功能：显示公司名称
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.01.09 15:13
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Company_Telephone
//函数功能：显示厂商电话
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.09.06 10:07
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Company_Http
//函数功能：显示厂商主页
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.09.06 10:07
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_Chip_ID
//函数功能：显示芯片ID号
//入口参数：无
//出口参数：无
//创建日期：2014.11.13
//修改日期：2014.11.13 13:31
//备注说明：无
//==========================================================
//STC12系列CPU内部ID号首地址定义(F1-F7为ID号)
#define MCU_ID_ADDR (0xF1)
//==========================================================

//==========================================================
////无序列号的显示固定值


//==========================================================
//函数名称：Disp_Product_ID
//函数功能：显示出厂编号
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.08.19 10:03
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_PowerOn_Menu
//函数功能：显示开机界面
//入口参数：无
//出口参数：无
//创建日期：2014.12.26
//修改日期：2015.08.18 09:38
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Group
//函数功能：显示组别
//入口参数：无
//出口参数：无
//创建日期：2015.01.05
//修改日期：2015.01.05 13:18
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Parameter_Value
//函数功能：显示设置值
//入口参数：step:第几步骤；index:第几项参数；highlight:非零高亮显示
//出口参数：无
//创建日期：2015.01.05
//修改日期：2015.09.06 09:14
//备注说明：数值位数+小数点+单位的长度固定为7个字符
//==========================================================


//==========================================================
//函数名称：Disp_SysMessage
//函数功能：显示系统信息
//入口参数：无
//出口参数：无
//创建日期：2014.10.15
//修改日期：2014.10.15 15:17
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_Idle_Menu
//函数功能：显示待测菜单
//入口参数：无
//出口参数：无
//创建日期：2015.10.26
//修改日期：2015.10.29 10:27
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Check_Parameter_Limit
//函数功能：参数值检查
//入口参数：无
//出口参数：无
//创建日期：2015.10.28 
//修改日期：2015.10.28 13:50
//备注说明：上限、下限检查,	L<=x<=H
//==========================================================
void Check_Parameter_Limit(void)
{
		u8 i;
		u8 *pt;
		pt=(u8* )&SaveData.Parameter;
		for(i=0;i<PARAMETER_MENU_MAX;i++)//共5项
		{
			if(*pt>ParameterLimit[i][0])//Max
				*pt= ParameterLimit[i][0];//Max
			if(*pt<ParameterLimit[i][1])//Min
				*pt=ParameterLimit[i][1];//Min
			pt++;
		}
}
//==========================================================
//函数名称：Range_Control
//函数功能：量程控制
//入口参数：u8 dat
//出口参数：无
//创建日期：2014.09.25
//修改日期：2015.09.04 15:35
//备注说明：量程(0-4) 100 1k 10k 100k 1M
//==========================================================

u8 Pga_value2[]={0x00,0x00,0x00,0x40,0x28,0x08,0x09};
u8 Pga_value[]={0x50,0x10,0x0C,0x0A,0x4A,0x28,0x08,0x09};

void Range_Control(u8 dat)
{
//    u8 buff;
    RangeChange_Flag=1;
    cpld_buff[0]=0xaa;
    if(dat>RANGE_MAX)
        dat=RANGE_MAX;
    //cpld_buff[1]&=0Xa1;
	cpld_buff[1]=Pga_value[dat];
    Send_To_Cpld(cpld_buff,2);
    if(dat==0)
        V_I_amp(1);
    else
        V_I_amp(0);
    delay_ms(100);
	
	cpld_buff[1]&=0XE1;
	Send_To_Cpld(cpld_buff,2);
	delay_ms(100);
}

void V_Range_Control(u8 dat)//0  不放大
{
    if(dat)
        dat=0;
    else
        dat=1;
    V_I_amp(dat);
    delay_ms(20);

}

//==========================================================
//函数名称：Disp_Setup_Menu
//函数功能：显示设置菜单
//入口参数：index:第几项
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 13:25
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_Parameter_Value
//函数功能：显示参数
//入口参数：index:第几项参数
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 11:25
//备注说明：无
//==========================================================

//==========================================================
//函数名称：ListBox_Setup
//函数功能：列表框设置
//入口参数：无
//出口参数：键值
//创建日期：2015.10.28
//修改日期：2015.10.28 09:50
//备注说明：标题栏字符长度,TITLE_LEN_MAX=8
//==========================================================

//==========================================================
//函数名称：Disp_Parameter_Menu
//函数功能：显示参数界面
//入口参数：无
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 13:20
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Parameter_Setup
//函数功能：参数菜单设置处理
//入口参数：无
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 11:49
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_System_Value
//函数功能：显示系统值
//入口参数：index:第几项参数
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 14:20
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Disp_System_Menu
//函数功能：显示系统界面
//入口参数：index:第几项参数
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 14:23
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Number_Setup
//函数功能：数值框设置处理
//入口参数：NumBox_TypeDef
//出口参数：键值
//创建日期：2015.10.28
//修改日期：2015.10.28 09:44
//备注说明：无
//==========================================================
//==========================================================
//函数名称：Range_Changecomp
//函数功能：电阻测试换挡
//入口参数：无
//出口参数：无
//创建日期：2015.10.26 
//修改日期：2015.10.29 13:35
//备注说明：无
//==========================================================
void Range_Changecomp(void)
{
	
//	bool f_disp=FALSE;//显示标志
	bool f_upper=FALSE;//量程过压标志
	bool f_below=FALSE;//量程欠压标志
	bool f_switch=FALSE;//量程切换标志
    bool V_upper=FALSE;//量程过压标志
	bool V_below=FALSE;//量程欠压标志
	bool V_switch=FALSE;//量程切换标志
	u8 i;
	//量程自动换挡处?
	if(fabs(Range_value)>RANGR_LIMIT_HIGH)//高于量程上限Ad_value
	{
		f_upper=TRUE;//量程过压标志
		f_below=FALSE;//量程欠压标志
		for(i=0;i<FIT_INUM;i++)
			i_buff[i]=0;
			ffit_data1=0;
			count_ffit=0;
	}
	else if(fabs(Range_value)<RANGR_LIMIT_LOW)//低于量程下限
	{
		f_below=TRUE;//量程低压标志
		f_upper=FALSE;//量程欠压标志
	}
	else
	{
		f_upper=FALSE;//量程过压标志
		f_below=FALSE;//量程欠压标志
	}
	f_switch=FALSE;//量程切换标志
	if(Jk516save.Set_Data.Range_Set==0)
	{
			if((Range<RANGE_MAX)&&(f_upper==TRUE))//量程非最高且低压
			{
				Range++;
				f_switch=TRUE;//量程切换标志
				for(i=0;i<FIT_INUM;i++)
				i_buff[i]=0;
				ffit_data1=0;
				count_ffit=0;
			} 
					else
			if((Range>0)&&(f_below==TRUE))//量程非最低且过压
			{
				Range--;
				f_switch=TRUE;//量程切换标志
				for(i=0;i<FIT_INUM;i++)
				i_buff[i]=0;
				ffit_data1=0;
				count_ffit=0;
			}
  }
	if(f_switch==TRUE)//量程切换标志
	{
        range_over=1;//增加不换档标志，用于查看是否在稳定的量程测量的

		Range_Control(Range);//量程控制
        f_switch=FALSE;
   
	}

    else
        range_over=0;
        
}

void VRange_Changecomp(void)
{
		bool f_upper=FALSE;//量程过压标志
		bool f_below=FALSE;//量程欠压标志
		bool f_switch=FALSE;//量程切换标志
		bool V_upper=FALSE;//量程过压标志
		bool V_below=FALSE;//量程欠压标志
		bool V_switch=FALSE;//量程切换标志
		range_over=1;
	
	  if(fabs(Range_Value_V)>RANGE_LIMIT_VHIGH)//高于量程上限Ad_value
    {
        V_upper=TRUE;  //量程过压标志
        V_below=FALSE; //量程欠压标志       
    }
    else if(fabs(Range_Value_V)<RANGE_LIMIT_VLOW)//低于量程下限
    {
        V_below=TRUE;  //量程低压标志
        V_upper=FALSE; //量程欠压标志
    }
    else
    {
        V_upper=FALSE; //量程过压标志
        V_below=FALSE; //量程欠压标志
    }
		V_switch=FALSE; //量程切换标志
		if((V_Range<RANGE_V_MAX)&&(V_upper==TRUE))//量程非最高且低压
		{
			V_Range++;
			V_switch=TRUE;//量程切换标志
			
		} 
		else
		if((V_Range>0)&&(V_below==TRUE))//量程非最低且过压
		{
			V_Range--;
			V_switch=TRUE;//量程切换标志
		   
		}
		if(V_switch==TRUE)
			V_Range_Control(V_Range);
		else
        range_over=0;

}
//==========================================================
//函数名称：Get_FFT
//函数功能：计算测试值结果
//入口参数：无
//出口参数：无
//创建日期：2014.11.08 
//修改日期：2015.08.27 14:43
//备注说明：更新Voltage
//==========================================================
void Get_FFT(void)
{

	ffit_data1++;	

	if(((Test_value.Test_I>40000)||(Test_value.Test_I<2000))&&(Range!=RANGE_MAX))
		ffit_data1=0;

	Float.Digit=Float.Digit/1000;

}

void Test_Debug(void)
{
    float a,b;
 
    disp_I=disp_I/Jk516cal.Debug_Value[Range].ad_value;
    disp_V=(float)disp_V/Jk516cal.Debug_Value[4+V_Range].ad_value;
   
}

//==========================================================
//函数名称：Read_Ad
//函数功能：读取A/D值
//入口参数：无
//出口参数：无
//创建日期：2014.11.08 
//修改日期：2015.08.26 10:32
//备注说明：无
//==========================================================
void Read_Ad(void)
{

	//Test_value.Test_v.Test_v=Read_Channel(1);//电流AD值
//    AD_Convert_read();
	
}
//==========================================================
//函数名称：System_Setup
//函数功能：系统设置处理
//入口参数：无
//出口参数：无
//创建日期：2015.10.28
//修改日期：2015.10.28 14:27
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Resistance_Setup
//函数功能：电阻数设置处理
//入口参数：NumBox_TypeDef
//出口参数：键值
//创建日期：2016.03.10
//修改日期：2016.03.10 13:44
//备注说明：无
//==========================================================

//==========================================================
//系统菜单项

//==========================================================

//==========================================================

//==========================================================

//==========================================================

//==========================================================
//函数名称：Check_System_Limit
//函数功能：系统值检查
//入口参数：步骤
//出口参数：无
//创建日期：2015.01.22 
//修改日期：2015.08.18 13:28
//备注说明：含上限、下限检查
//==========================================================


//==========================================================
//函数名称：Disp_System_Info
//函数功能：显示系统信息
//入口参数：u8 index-第几项
//出口参数：无
//创建日期：2015.01.21
//修改日期：2015.08.19 09:48
//备注说明：按index进行分页显示
//==========================================================

//==========================================================
//函数名称：Disp_System_Menu
//函数功能：显示系统界面
//入口参数：无
//出口参数：无
//创建日期：2015.01.22
//修改日期：2015.08.19 09:00
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_System_Value
//函数功能：显示系统值
//入口参数：index:第几项参数
//出口参数：无
//创建日期：2015.01.21
//修改日期：2015.09.06 09:06
//备注说明：数值位数+小数点+单位的长度固定为4个字符
//==========================================================

//==========================================================
//函数名称：System_Setup
//函数功能：系统设置处理
//入口参数：无
//出口参数：无
//创建日期：2015.01.21
//修改日期：2015.09.06 09:10
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Password_Check
//函数功能：密码校验
//入口参数：无
//出口参数：TRUE:有效
//创建日期：2015.01.29 
//修改日期：2015.08.24 11:40
//备注说明：无
//==========================================================

//==========================================================

//==========================================================
//密码项

//==========================================================
//函数名称：Disp_Password_Info
//函数功能：显示密码信息
//入口参数：无
//出口参数：无
//创建日期：2015.01.23
//修改日期：2015.08.19 10:45
//备注说明：无
//==========================================================

//==========================================================
//函数名称：Password_Setup
//函数功能：密码设置处理
//入口参数：无
//出口参数：无
//创建日期：2015.01.23
//修改日期：2015.08.20 11:03
//备注说明：无
//==========================================================

//==========================================================
//函数名称：FactoryInfo_Setup
//函数功能：出厂信息设置处理
//入口参数：无
//出口参数：无
//创建日期：2015.01.14
//修改日期：2015.08.24 11:54
//备注说明：
//按上下键：显示仪器信息；
//长按右键：进入出厂配置设置界面
//长按左键：加载默认出厂设置值
//长按设置：系统复位处理
//==========================================================


//==========================================================
//函数名称：Disp_Factory_Info
//函数功能：显示出厂信息
//入口参数：无
//出口参数：无
//创建日期：2015.01.09
//修改日期：2015.08.19 10:01
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_Instrument_Info
//函数功能：显示仪器信息
//入口参数：无
//出口参数：无
//创建日期：2015.01.22
//修改日期：2015.08.20 15:52
//备注说明：无
//==========================================================


//==========================================================
//配置项

//==========================================================
//配置项

//==========================================================
//配置项上、下限

 
//==========================================================
//函数名称：Check_Config_Limit
//函数功能：配置值检查
//入口参数：步骤
//出口参数：无
//创建日期：2015.01.22 
//修改日期：2015.09.06 11:15
//备注说明：含上限、下限检查
//==========================================================

//==========================================================
//函数名称：Disp_Config_Info
//函数功能：显示配置信息
//入口参数：无
//出口参数：无
//创建日期：2015.01.21
//修改日期：2015.08.19 10:17
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_Config_Menu
//函数功能：显示配置界面
//入口参数：无
//出口参数：无
//创建日期：2015.01.22
//修改日期：2015.08.19 10:16
//备注说明：无
//==========================================================


//==========================================================
//函数名称：Disp_Config_Value
//函数功能：显示配置值
//入口参数：index:第几项参数
//出口参数：无
//创建日期：2015.01.22
//修改日期：2015.08.19 10:22
//备注说明：数值位数+小数点+单位的长度固定为4个字符
//==========================================================


//==========================================================
//函数名称：Config_Setup
//函数功能：配置设置处理
//入口参数：无
//出口参数：无
//创建日期：2015.01.22
//修改日期：2015.08.19 10:29
//备注说明：无
//==========================================================

////==========================================================

////==========================================================
////函数名称：Disp_SysStatus
////函数功能：显示系统状态
////入口参数：无
////出口参数：无
////创建日期：2014.10.15
////修改日期：2014.10.15 15:17
////备注说明：无
////==========================================================

//==========================================================

//==========================================================
//函数名称：Disp_SysMessage
//函数功能：显示系统信息
//入口参数：无
//出口参数：无
//创建日期：2014.10.15
//修改日期：2014.10.15 15:17
//备注说明：无
//==========================================================

//==========================================================
//开机界面-整屏图片格式
//常州扬子(48*48)
//常州扬子电子有限公司(16*16)
//常州市新北区庆阳路2号
//电话：88226706 8826707
void _4094_data(void)
{
	_4094_databuff[0]=U16_4094;
	_4094_databuff[1]=U15_4094;
//	_4094_databuff[2]=U22_4094;
//	_4094_databuff[3]=_U21_4094;

}


//电阻计算，电压/电流*倍率
//void Get_Res(void)
//{
//	Res_count.r=Res_count.v*Res_count.rate/Res_count.i;
//}
uint32_t  ReadBE32U (volatile  uint8_t  *pmem)
{
    uint32_t   val;

    ((uint8_t *)&val)[0] = pmem[3];
    ((uint8_t *)&val)[1] = pmem[2];
    ((uint8_t *)&val)[2] = pmem[1];
    ((uint8_t *)&val)[3] = pmem[0];
    return (val);
}

Sort_TypeDef StrToint(vu8 *list)
{
    u32 date;
    Sort_TypeDef returndate;
    date=ReadBE32U(list);
    returndate.Num=date;
    returndate.Dot=list[4];
    returndate.Unit=list[5];
    return returndate;
    
}

void ComToSave(Rev_Combuff_Typedef *buff)
{
    Jk516save.Set_Data.trip=buff->Trip;
    Jk516save.Set_Data.speed=buff->Speed;
    Jk516save.Set_Data.Res_comp=buff->R_comp;    
    Jk516save.Set_Data.Res_low=StrToint((buff->Rev_LoRes));
    Jk516save.Set_Data.V_comp=buff->Rev_V_comp;
    Jk516save.Set_Data.V_comp=buff->Rev_V_comp;
    Jk516save.Set_Data.V_low=StrToint((buff->Rev_V_Lo));
    Jk516save.Set_Data.Range=buff->Range;
    Jk516save.Set_Data.beep=buff->Beep;
    Jk516save.Set_Data.Nominal_Res=StrToint((buff->Norm_Res));
    Jk516save.Set_Data.High_Res=StrToint((buff->Rev_Hires));
    Jk516save.Set_Data.Nominal_V=StrToint((buff->Norm_V));
    Jk516save.Set_Data.V_high=StrToint((buff->Rev_VHi));
}

void Uart_Process(void)
{
	u8 i;
    u8 king;
    Rev_Combuff_Typedef *pt;
    pt=&Rev_Combuff;
        
    if (ComBuf.rec.end)
    {
         ComBuf.rec.end=FALSE;
         for(i=0;i<REC_LEN_MAX;i++)
             debug_buff[i]=ComBuf.rec.buf[i];
         king=debug_buff[1];
         switch(king)
         {
             case 0xF1://写设置数据
                 memcpy(pt,&ComBuf.rec.buf[2],sizeof(Rev_Combuff));  //这里错误 要改正
                 ComToSave(&Rev_Combuff);               
             break;
             case 0xf2://写校正命令
                 debug_flag=1;
                 Set_flag=1;
                 
             break;
             case 0xfe://清零命令
             break;
             case 0xf3://写校正数据
                 
             break;
             case 0xf4://读测试值
                 Send_Uart3str((char *)&Send_ComBuff);

             break;
             case 0xf5://设置扫描板地址
                
             break;
             case 0xf6:
                 break;
             case 0xfa://启动，单次或者扫描的时候用
                 test_start=1;
             break;
             case 0xfb://复位 扫描时候用
                test_start=0;
                
             break;
             default:
             break;
         
         }
         
        
        
    }

}

const u8 send_dot[]={3,3,2,4,2,4,3,2,4,3,2};
const u8 send_dot1[]={3,2,1,3,2,4,3,2,4,3,2};
const u8 Send_uint[]={0,0,0,1,1,2,2,2,3,6,6};
Test_ValueTypedef Datacov(s32 value,u8 range)
{
    Test_ValueTypedef midvalue;
    
    midvalue.polar=polarity_r;
    midvalue.res=value;
	if(Jk516save.dispdot == 0)
	{
		midvalue.dot=send_dot[range];
	}else if(Jk516save.dispdot == 1){
		midvalue.dot=send_dot1[range];
	}
		
    midvalue.uint=Send_uint[range];
    return midvalue;

}


Test_ValueTypedef V_Datacov(s32 value ,u8 range)
{
    Test_ValueTypedef midvalue;
    
    midvalue.polar=polarity_v;
        
    midvalue.res=value;	
    if(range)
        midvalue.dot=3;
    else
        midvalue.dot=4;
    midvalue.uint=0;
    return midvalue;

}

u8 Comp_choice(void)//三种模式分选
{
    u8 comp=0;// 0 合格  1  失败
    u32 testvalue,hi_value,lo_value;
//    testvalue=(u32)Test_Value.res*pow(10,Test_Value.uint-3)/pow(10,Test_Value.dot);//减3以后是m欧姆为单位
//    hi_value=(u32)Jk516save.Compset.Hi_limit.value*pow(10,Jk516save.Compset.Hi_limit.unit-3)/pow(10,Jk516save.Compset.Hi_limit.dot);
//    lo_value=(u32)Jk516save.Compset.Low_limit.value*pow(10,Jk516save.Compset.Low_limit.unit-3)/pow(10,Jk516save.Compset.Low_limit.dot);
    if(testvalue>=hi_value)
        comp=1;//上限失败
    else if(testvalue<=lo_value)
        comp=2;//下限失败
    else
        comp=0;//合格
    return comp;
    
    
}
void Beep_Out(u8 flag)
{
    if(Jk516save.Set_Data.beep==0)
	{
        BEEP_OFF;
	}
    else
    {
        if(flag==0)//合格
        {
            if(Jk516save.Set_Data.beep==1)//合格响
            {
                BEEP_ON;
            }
            else
                BEEP_OFF;
        }
        else//不合格
        {
            if(Jk516save.Set_Data.beep==2)//不合格响
            {
                BEEP_ON;
            }
            else
                BEEP_OFF;
        }
    }

}

const u8 Test_Uint[][4]=
{
    {"mΩ"},
    {" Ω"},
    {"kΩ"},
    {"MΩ"},

};
void Disp_Open(void)
{
    u32 colour;
	Colour.Fword = White;
    colour= Colour.black;
    Colour.black=LCD_COLOR_TEST_BACK;
   // if(Jk516save.Set_Data.speed!=3)
    {
//        if(Jk516save.Set_Data.speed==0)
//        {
//            WriteString_Big ( TESTVALUE_X-32, TESTVALUE_Y, "--------",0 );
//            WriteString_Big ( TESTVALUE_X-32, TESTVALUE_Y+TEST_VALUE_YMID, "--------",0 );
//        }
//        else
        {
            WriteString_Big ( TESTVALUE_X+32+48, 168+3, "------",2 );
            WriteString_Big ( TESTVALUE_X+32, 268+3, " ------",2 );
        
        }
    }
//    else
//    {
//         WriteString_16 ( TESTVALUE_X, TESTVALUE_Y+32, "--------",0);
//         WriteString_16 ( TESTVALUE_X, TESTVALUE_Y+TEST_VALUE_YMID+32, "--------",0 ); 
//    
//    }
    Close_Compled();
	BEEP_OFF;
	colour= LCD_COLOR_TEST_BACK;
    Colour.black=LCD_COLOR_TEST_BACK;
	LCD_DrawFullRect(SORTING_XDISP, SORTING_Y_DISP, 100, 23);
    Colour.black=colour;
    Disp_Range(Jk516save.Set_Data.Range_Set,Range);
    

}
void Disp_Testvalue(Test_ValueTypedef value,Test_ValueTypedef value_v,u8 speed)
{
    u8 i;
    u32 Res_disp;
    Res_disp=value.res;
	  Colour.black = LCD_COLOR_TEST_BACK;
	  Colour.Fword = White;
    for(i=0;i<9;i++)
      DispBuf[i]=0;
    #ifdef BASTARDLY
    if(value.res>last_R_disp)
    {
       date= value.res-last_R_disp;
    
    }
    else
    {
        date=last_R_disp-value.res;

    }
    if(date>=3)
    {
        last_R_disp=value.res;
        Res_disp=value.res;
    
    }
    else
    {
        Res_disp=last_R_disp;
    
    }
    #endif
    if(Res_disp>35000)
    {
        for(i=0;i<6;i++)
        DispBuf[i]='-';
        
    }
    else{
//		if(Jk516save.dispdot == 0)
//		{
//			Hex_Format(Res_disp , value.dot , 4, FALSE);
//		}else if(Jk516save.dispdot == 1){
			Hex_Format(Res_disp , value.dot , 5, FALSE);
//		}
	}
    memcpy((void *)Send_ComBuff.send_res,DispBuf,5);
    memcpy((void *)Send_To_U.Send_res,DispBuf,6);//电阻
    memcpy((void *)&Send_To_U.Send_res[6],DISP_UINT[Test_Value.uint],3);//单位
		Send_To_U.back=9;
		WriteString_Big ( TESTVALUE_X+48+32, TESTVALUE_Y+20, DispBuf ,2); 
		
		if(Range <3)
				LCD_ShowFontCN_40_55(TESTVALUE_X+48*8,200-2,40,55,(uint8_t*)Out_Assic+17*40*55/8);//m
		else
				LCD_ShowFontCN_40_55(TESTVALUE_X+48*8,200-2,40,55,(uint8_t*)Out_Assic+22*40*55/8);//m
    
		Hex_Format(value_v.res , value_v.dot , 5, FALSE);
		
    memcpy((void *)&Send_ComBuff.send_V[1], DispBuf, 6);
		
    memcpy((void *)&Send_To_U.Send_V[1], DispBuf, 6);//存U盘
		
    Send_To_U.Send_V[7]='V';
	Send_To_U.Send_V[8]=' ';	
    Send_To_U.back1=9;
		
    memcpy((void *)&Send_To_U.ret[0],"\r\n",2);
		
    if(value_v.polar)
        WriteString_Big ( TESTVALUE_X+32, TESTVALUE_Y+TEST_VALUE_YMID+20, " ",2 ); 
    else
        WriteString_Big ( TESTVALUE_X+32, TESTVALUE_Y+TEST_VALUE_YMID+20, "-",2 );
         
		WriteString_Big ( TESTVALUE_X+32+48, TESTVALUE_Y+TEST_VALUE_YMID+20, DispBuf,2 ); 

    if(value_v.polar)
    {
        Send_ComBuff.send_V[0]=' ';
        Send_To_U.Send_V[0]=' ';
         
    }
    else
    {
        Send_ComBuff.send_V[0]='-';
        Send_To_U.Send_V[0]='-';
         
    }
    Send_ComBuff.send_res[6]=Test_Value.uint;
 
}

void Disp_xxx(u16 data,u16 pos)
{
    Hex_Format(data , 0 , 5, FALSE);
    LCD_DispString_EN_CH( TESTVALUE_X+pos, TESTVALUE_Y, DispBuf );
}


//显示 快捷键按键  画矩形的底层函数要移植
void Disp_Fastbutton(void)
{
	uint32_t i;
	
	for( i = 0;i < 5; i++ )
	{
       Colour.black = LCD_COLOR_TEST_BUTON;
		   LCD_DrawFullRect( 4*i + i*124, 414, 124, 66 ) ;
		
       Colour.black = LCD_COLOR_GREY;
       LCD_DrawFullRect( 124*i + 4*i, 414, 124, 2 );
       LCD_DrawFullRect( 124*i + 4*i, 414, 2, 66 );
	}
}

void Disp_Button_value1( uint32_t value )
{
		u8 i;
		Disp_Fastbutton();
		if(value == 0)
		{
			Colour.Fword = LCD_COLOR_BUTTON;
			Colour.black = LCD_COLOR_TEST_BUTON;
		
			if( Jk516save.Sys_Setvalue.lanage )
			{
				WriteString_16(25, BUTTON_1+5, "MEAS",  0);
				WriteString_16(25, BUTTON_2, "DISP",  0);
				WriteString_16(25 + BUTTON_W, BUTTON_1+5, "MEAS",  0);
				WriteString_16(25 + BUTTON_W, BUTTON_2, "SETUP",  0);
				WriteString_16(25 + BUTTON_W*2, BUTTON_1+5, "DATA",  0);
				WriteString_16(25 + BUTTON_W*2, BUTTON_2, "REVIEW",  0);
				WriteString_16(25 + BUTTON_W*3, BUTTON_1+5, "SYS",  0);
				WriteString_16(25 + BUTTON_W*3, BUTTON_2, "INFO",  0);
				
				if( GetSystemStatus() == SYS_STATUS_TEST )
				{
						WriteString_16(25 + BUTTON_W*4, BUTTON_1+5, "CLEAR",  0);
						WriteString_16(25 + BUTTON_W*4, BUTTON_2, "VALUE",  0);
				}else if(GetSystemStatus() == SYS_STATUS_SETUP){
						WriteString_16(25 + BUTTON_W*4, BUTTON_1+5, " SYS",  0);
						WriteString_16(10 + BUTTON_W*4, BUTTON_2, "UPDATE",  0);
				}
			}
			else
			{
				WriteString_16(24, BUTTON_1+5, "测 量",  0);
				WriteString_16(24, BUTTON_2, "显 示",  0);
				WriteString_16(24 + BUTTON_W, BUTTON_1+5, "测 量",  0);
				WriteString_16(24 + BUTTON_W, BUTTON_2, "设 置",  0);
				
//				WriteString_16(24 + BUTTON_W*3, BUTTON_1+5, "数 据",  0);
//				WriteString_16(24 + BUTTON_W*3, BUTTON_2, "查 看",  0);
			
				if(GetSystemStatus() == SYS_STATUS_TEST)
				{
						if(recordflag == 0)
						{
							WriteString_16(24 + BUTTON_W*2, BUTTON_1+5, "开 始",  0);
							WriteString_16(24 + BUTTON_W*2, BUTTON_2, "记 录",  0);
						}else if(recordflag == 1){
							WriteString_16(24 + BUTTON_W*2, BUTTON_1+5, "停 止",  0);
							WriteString_16(24 + BUTTON_W*2, BUTTON_2, "记 录",  0);
						}
						WriteString_16(24 + BUTTON_W*3, BUTTON_1+5, "数 据",  0);
						WriteString_16(24 + BUTTON_W*3, BUTTON_2, "保 持",  0);
						WriteString_16(24 + BUTTON_W*4, BUTTON_1+5, "短 路",  0);
						WriteString_16(24 + BUTTON_W*4, BUTTON_2, "清 零",  0);
				}else if(GetSystemStatus() == SYS_STATUS_SETUP){
						WriteString_16(24 + BUTTON_W*2, BUTTON_1+5, "系 统",  0);
						WriteString_16(24 + BUTTON_W*2, BUTTON_2, "设 置",  0);
						WriteString_16(24 + BUTTON_W*3, BUTTON_1+5, "数 据",  0);
						WriteString_16(24 + BUTTON_W*3, BUTTON_2, "查 看",  0);
						WriteString_16(25 + BUTTON_W*4, BUTTON_1+5, "固 件",  0);
						WriteString_16(25 + BUTTON_W*4, BUTTON_2, "升 级",  0);
				}else if(GetSystemStatus() == SYS_STATUS_SYS || GetSystemStatus() == SYS_STATUS_SYSSET){
						WriteString_16(24 + BUTTON_W*2, BUTTON_1+5, "系 统",  0);
						WriteString_16(24 + BUTTON_W*2, BUTTON_2, "设 置",  0);
						WriteString_16(24 + BUTTON_W*3, BUTTON_1+5, "系 统",  0);
						WriteString_16(24 + BUTTON_W*3, BUTTON_2, "信 息",  0);
				}
			}
		}
		else if(value == 1)
		{
				Colour.Fword=White;
				Colour.black = LCD_COLOR_TEST_BUTON;
				WriteString_16(84, 271-40+5, "文件",  0);
				WriteString_16(84, 271-20, "管理",  0);
				WriteString_16(84+80, 271-40+5, "保存",  0);
				WriteString_16(84+80, 271-20, "数据",  0);
				WriteString_16(84+320, 271-40+5, "更多",  0);
				WriteString_16(84+320, 271-20, " 2/2",  0);
		}else if(value == 2){
			Colour.Fword = LCD_COLOR_BUTTON;
			Colour.black = LCD_COLOR_TEST_BUTON;
		
			if( Jk516save.Sys_Setvalue.lanage )
			{
				WriteString_16(25, BUTTON_1+5, "MEAS",  0);
				WriteString_16(25, BUTTON_2, "DISP",  0);
				WriteString_16(25 + BUTTON_W, BUTTON_1+5, "MEAS",  0);
				WriteString_16(25 + BUTTON_W, BUTTON_2, "SETUP",  0);
				WriteString_16(25 + BUTTON_W*2, BUTTON_1+5, "DATA",  0);
				WriteString_16(25 + BUTTON_W*2, BUTTON_2, "REVIEW",  0);
				WriteString_16(25 + BUTTON_W*3, BUTTON_1+5, "SYS",  0);
				WriteString_16(25 + BUTTON_W*3, BUTTON_2, "INFO",  0);
				
				if( GetSystemStatus() == SYS_STATUS_TEST )
				{
						WriteString_16(25 + BUTTON_W*4, BUTTON_1+5, "CLEAR",  0);
						WriteString_16(25 + BUTTON_W*4, BUTTON_2, "VALUE",  0);
				}else if(GetSystemStatus() == SYS_STATUS_SETUP){
						WriteString_16(25 + BUTTON_W*4, BUTTON_1+5, " SYS",  0);
						WriteString_16(10 + BUTTON_W*4, BUTTON_2, "UPDATE",  0);
				}
			}
			else
			{
				WriteString_16(24, BUTTON_1+5, "测 量",  0);
				WriteString_16(24, BUTTON_2, "显 示",  0);
				WriteString_16(24 + BUTTON_W, BUTTON_1+5, "全 部",  0);
				WriteString_16(24 + BUTTON_W, BUTTON_2, "删 除",  0);
				WriteString_16(24 + BUTTON_W*2, BUTTON_1+5, " 上",  0);
				WriteString_16(24 + BUTTON_W*2, BUTTON_2, "一 页",  0);
				WriteString_16(24 + BUTTON_W*3, BUTTON_1+5, " 下",  0);
				WriteString_16(24 + BUTTON_W*3, BUTTON_2, "一 页",  0);
				WriteString_16(24 + BUTTON_W*4, BUTTON_1+5, "返 回",  0);
				WriteString_16(24 + BUTTON_W*4, BUTTON_2, "目 录",  0);

			}
		}

}


void Disp_Button_TestSet(uint32_t value)
{

  	if(value==0)
		{
				Colour.Fword = White;
				Colour.black = LCD_COLOR_TEST_BUTON;
				WriteString_16(84, 271-40+5, "测量",  0);
				WriteString_16(84, 271-20, "显示",  0);
				WriteString_16(84+80, 271-40+5, "测量",  0);
				WriteString_16(84+80, 271-20, "设置",  0);
				WriteString_16(84+160, 271-40+5, "系统",  0);
				WriteString_16(84+160, 271-20, "设置",  0);
				WriteString_16(84+240, 271-40+5, "系统",  0);
				WriteString_16(84+240, 271-20, "信息",  0);
		}
		else if(value==1)
		{
				Colour.Fword = White;
				Colour.black = LCD_COLOR_TEST_BUTON;
				WriteString_16(84, 271-40+5, "文件",  0);
				WriteString_16(84, 271-20, "管理",  0);
				WriteString_16(84+80, 271-40+5, "系统",  0);
				WriteString_16(84+80, 271-20, "设置",  0);
				WriteString_16(84+160, 271-30+5, "工具",  0);
				WriteString_16(84+320, 271-40+5, "更多",  0);
				WriteString_16(84+320, 271-20, " 2/2",  0);
		}
}
void Disp_Button_SysSet(void)
{
		Disp_Button_value1(0);
	
}
void Disp_TopBar_Color(void)
{
    Colour.black = LCD_COLOR_TEST_BAR;
    LCD_DrawFullRect(0, 0, 260, 33);

}
void Disp_MidRect(void)
{

}

void Disp_TestScreen(void)
{
	Disp_TopBar_Color();   //左上角
	Disp_Fastbutton();    //显示快速按键  菜单黑框加外框

}


//
//测量显示主菜单的项目显示
//
void Disp_Test_Item(void)
{
		uint32_t i;
		const u8 (*pt)[sizeof(Test_Setitem[0])];
		const u8 (*ppt)[sizeof(All_TopName[0])];
			
		Disp_TestScreen();
	
		Colour.Fword = White;
		Colour.black = LCD_COLOR_TEST_BAR;
		if( Jk516save.Sys_Setvalue.lanage )
			 ppt = All_TopName_E;
		else
			 ppt = All_TopName;
			
		WriteString_16( LIST1 , 5, ppt[0],  0);   //显示右上角测量显示
			
		Colour.Fword = 0X00BFFF;
		Colour.black = LCD_COLOR_TEST_BACK;
		
		if(Jk516save.Sys_Setvalue.lanage)
			 pt = Test_Setitem_E;
		else
			 pt = Test_Setitem;
		
		for( i = 0;i < 6; i++ )     //测试页面的表列名
		{
			  if(i < 3)
				    LCD_DispString_MS24x23( LIST1, FIRSTLINE + i * ( HIGH1 + 10) + 10, pt[i]);
			  else
				    LCD_DispString_MS24x23( LIST2, FIRSTLINE + ( i - 3 ) * ( HIGH1+ 10) + 10 , pt[i]);
		}
		
		Disp_Button_value1(0);
}

//测试页面显示的值
void Disp_Test_value(u8 num)
{
		vu32 i;
		const u8 (*ppt)[11];
		const u8 (*pt)[7];
		vu32 Black_Select;
		if( Jk516save.Sys_Setvalue.lanage )
    {
        pt = Test_Tirpvalue_E;
    }
    else
    {
        pt = Test_Tirpvalue;
    
    }
		
		//触发
		Black_Select = ( num == 1 ) ? 1 : 0;
		if(Black_Select)
		{
			 Colour.black = LCD_COLOR_SELECT;
		}
		else
		{
			 Colour.black = LCD_COLOR_TEST_BACK;
		}
		LCD_DrawFullRect( DISPX1, FIRSTLINE+12, RECT , HIGH1-5 ) ;
		Colour.Fword = LCD_COLOR_YELLOW;
		LCD_DispString_MS24x23( DISPX1, FIRSTLINE+12, pt[Jk516save.Set_Data.trip]);
	
    //电阻上限
		Black_Select = ( num == 2 ) ? 1 : 0;
		if(Black_Select)
		{
			Colour.black = LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black = LCD_COLOR_TEST_BACK;
		}
		Hex_Format( Jk516save.Set_Data.High_Res.Num, Jk516save.Set_Data.High_Res.Dot, 6 , 0);
		LCD_DrawFullRect( DISPX1, FIRSTLINE+HIGH1+15, RECT, HIGH1  ) ;
		LCD_DispString_EN_CH( DISPX1, FIRSTLINE+HIGH1+15, DispBuf);   
		LCD_DispString_MS24x23( DISPX1+7*16, FIRSTLINE+HIGH1+18, DISP_UINT[Jk516save.Set_Data.High_Res.Unit]);
	
		//电阻下限
		Black_Select = ( num == 3) ? 1 : 0;
		if(Black_Select)
		{
			  Colour.black = LCD_COLOR_SELECT;
		}
		else
		{ 
			  Colour.black = LCD_COLOR_TEST_BACK;
		}
		Hex_Format( Jk516save.Set_Data.Res_low.Num , Jk516save.Set_Data.Res_low.Dot, 6 , 0);
		LCD_DrawFullRect( DISPX1, FIRSTLINE+HIGH1*2+25, RECT, HIGH1 ) ;
		LCD_DispString_EN_CH( DISPX1, FIRSTLINE+HIGH1*2+25, DispBuf);
		LCD_DispString_MS24x23( DISPX1+7*16, FIRSTLINE+HIGH1*2+28,DISP_UINT[Jk516save.Set_Data.Res_low.Unit]);
	
	  //量程
		Black_Select = ( num == 4) ? 1 : 0;
		if(Black_Select)
		{
			 Colour.black = LCD_COLOR_SELECT;
		
		}
		else
		{
			 Colour.black = LCD_COLOR_TEST_BACK;
		}
		if( Jk516save.Sys_Setvalue.lanage )
    {
        ppt = User_Range_E;
    }
    else
    {
        ppt = User_Range;
    
    }	
		LCD_DrawFullRect( DISPX2, FIRSTLINE+12, SELECT_2END-LIST2-150, HIGH1-5) ;//SPACE1
    if( Jk516save.Set_Data.Range_Set == 0 )
        
        LCD_DispString_MS24x23( DISPX2, FIRSTLINE+12, ppt[0]);
    else
        LCD_DispString_MS24x23( DISPX2, FIRSTLINE+12, ppt[Jk516save.Set_Data.Range+1]);
	
	  //电压上限
		Black_Select = ( num == 5 ) ? 1 : 0;
		if(Black_Select)
		{
			Colour.black = LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black = LCD_COLOR_TEST_BACK;
		}

		Hex_Format( Jk516save.Set_Data.V_high.Num , Jk516save.Set_Data.V_high.Dot, 6, 0);
		LCD_DrawFullRect( DISPX2-16, FIRSTLINE+HIGH1+15 ,SELECT_2END-LIST2-128, HIGH1) ;//SPACE1
		LCD_DispString_EN_CH( DISPX2-16, FIRSTLINE+HIGH1+15, DispBuf);
		LCD_DispString_MS24x23( DISPX2+16*8, FIRSTLINE+HIGH1+18, "V");
	
		//电压下限
		Black_Select = ( num == 6 ) ? 1 : 0;
		if(Black_Select)
		{
			Colour.black = LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black = LCD_COLOR_TEST_BACK;
		}

		Hex_Format( Jk516save.Set_Data.V_low.Num, Jk516save.Set_Data.V_low.Dot, 6 , 0);
		LCD_DrawFullRect( DISPX2-16, FIRSTLINE+HIGH1*2+25, SELECT_2END-LIST2-128, HIGH1) ;//SPACE1
		LCD_DispString_EN_CH( DISPX2-16, FIRSTLINE+HIGH1*2+25, DispBuf);
		LCD_DispString_MS24x23( DISPX2+16*8, FIRSTLINE+HIGH1*2+28, "V");
		
		Disp_Fastbutton();
		
		//按钮
		switch(num)
		{
			  case 0:
						Disp_Button_value1(0);
				break;
				case 1:
			
						Colour.Fword = LCD_COLOR_BUTTON;
						Colour.black = LCD_COLOR_TEST_BUTON;
					
						if(Jk516save.Sys_Setvalue.lanage)
						{
								pt = Test_Tirpvalue_E;
						}
						else
						{
								pt = Test_Tirpvalue;
									
						}
						for( i = 0; i < 2 ; i++ )
								LCD_DispString_MS24x23( SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i]);
			
				break;
				case 2:
						Colour.Fword = LCD_COLOR_BUTTON;
						Colour.black = LCD_COLOR_TEST_BUTON;
						if(Jk516save.Sys_Setvalue.lanage)
						{
								pt = INPUT_E;
						}
						else
						{
								pt = INPUT;
							
						}
						for( i = 0; i < 1; i++ )
								LCD_DispString_MS24x23( SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i]);
			break;
			case 3:
						Colour.Fword = LCD_COLOR_BUTTON;
						Colour.black = LCD_COLOR_TEST_BUTON;
						if(Jk516save.Sys_Setvalue.lanage)
						{
								pt = INPUT_E;
						}
						else
					  {
								pt = INPUT;
							
						}
						for( i = 0; i < 1; i++ )
								LCD_DispString_MS24x23( SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i]);
			break;

			case 4:
						Colour.Fword = LCD_COLOR_BUTTON;
						Colour.black = LCD_COLOR_TEST_BUTON;
						for( i = 0; i < 5; i++ )
							  LCD_DispString_MS24x23( 8+i*BUTTON_W, BUTTON_1+16, User_Rangeset[i]);
			break;
			case 5:
						Colour.Fword = LCD_COLOR_BUTTON;
						Colour.black = LCD_COLOR_TEST_BUTON;
						if( Jk516save.Sys_Setvalue.lanage )
						{
								pt = INPUT_E;
						}
						else
						{
								pt = INPUT;		
						}
						for( i = 0; i < 1; i++ )
							  LCD_DispString_MS24x23( SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i]);
			break;
			case 6:
						Colour.Fword = LCD_COLOR_BUTTON;
						Colour.black = LCD_COLOR_TEST_BUTON;
						if(Jk516save.Sys_Setvalue.lanage)
						{
								pt = INPUT_E;
						}
						else
						{
								pt = INPUT;
							
						}
						for( i = 0; i < 1; i++ )
							  LCD_DispString_MS24x23( SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i]);
				break;
			default:
				
			break;
		}

}

void Disp_TestSet_MidRect(void)
{

    Disp_MidRect();
}

void Disp_TestSetScreen(void)
{
		Disp_TopBar_Color();
		Disp_Fastbutton();

}

//列表显示界面	 
void Disp_Test_Set_Item(void)
{
		uint32_t i;
    const u8 (*pt)[sizeof(Set_testitem[0])];
    const u8 (*ppt)[sizeof(All_TopName[0])];
    
		Disp_TestSetScreen();
	
		Colour.Fword = White;
		Colour.black = LCD_COLOR_TEST_BAR;
		if( Jk516save.Sys_Setvalue.lanage )
        ppt = All_TopName_E;
    else
        ppt = All_TopName;
		WriteString_16( 0, 4, ppt[4],  0);
		
		Colour.Fword = LCD_COLOR_SET;
		Colour.black = LCD_COLOR_TEST_BACK;
    if( Jk516save.Sys_Setvalue.lanage )
        pt = Set_testitem_E;
    else
        pt = Set_testitem;
		
		Colour.black = LCD_COLOR_TEST_BACK;	   
		for( i = 0; i < (sizeof(Set_testitem)/(sizeof(Set_testitem[0]))); i++ )
			if( i < sizeof(Set_testitem)/(sizeof(Set_testitem[0]))/2 )
					WriteString_16( LIST1, FIRSTLINE+HIGH1*i, pt[i], 0);
			else
					WriteString_16( LIST2, FIRSTLINE+HIGH1*(i-sizeof(Set_testitem)/(sizeof(Set_testitem[0]))/2), pt[i],  0);
		Disp_Button_value1(0);

}


void Disp_SD_VIEW_Item(void)
{
	uint32_t i;
    const u8 (*pt)[sizeof(Set_testitem[0])];
    const u8 (*ppt)[sizeof(All_TopName[0])];
	
	Disp_TestSetScreen();
	
		Colour.Fword = White;
		Colour.black = LCD_COLOR_TEST_BAR;
		if( Jk516save.Sys_Setvalue.lanage )
        ppt = All_TopName_E;
    else
        ppt = All_TopName;
		WriteString_16( 0, 4, ppt[11],  0);
		
//		Colour.Fword = LCD_COLOR_SET;
//		Colour.black = LCD_COLOR_TEST_BACK;
//    if( Jk516save.Sys_Setvalue.lanage )
//        pt = Set_testitem_E;
//    else
//        pt = Set_testitem;
//		
//		Colour.black = LCD_COLOR_TEST_BACK;	   
//		for( i = 0; i < (sizeof(Set_testitem)/(sizeof(Set_testitem[0]))); i++ )
//			if( i < sizeof(Set_testitem)/(sizeof(Set_testitem[0]))/2 )
//					WriteString_16( LIST1, FIRSTLINE+HIGH1*i, pt[i], 0);
//			else
//					WriteString_16( LIST2, FIRSTLINE+HIGH1*(i-sizeof(Set_testitem)/(sizeof(Set_testitem[0]))/2), pt[i],  0);
		Disp_Button_value1(2);
}
//显示设置参数的值Setup_Valueall
void DispSet_value(u8 keynum)
{
			vu32 i;
			const u8 (*pt)[7];
			const u8 (*ppt)[11];
			vu32 Black_Select;
			Colour.Fword = LCD_COLOR_YELLOW;
			Black_Select = ( keynum == 1 ) ? 1 : 0;
			//触发
			if(Black_Select)
			{
				Colour.black=LCD_COLOR_SELECT;
			}
			else
			{
				Colour.black=LCD_COLOR_TEST_BACK;
			}
			if(Jk516save.Sys_Setvalue.lanage)
			{
					pt=Test_Tirpvalue_E;
			
			}
			else
			{
					pt=Test_Tirpvalue;
			
			}
			LCD_DrawFullRect( DISPX1, FIRSTLINE, RECT, HIGH1  ) ;	
			WriteString_16(DISPX1+16, FIRSTLINE, pt[Jk516save.Set_Data.trip],  0);
		
			//速度	
			Black_Select=(keynum==2)?1:0;
			if(Black_Select)
			{
				Colour.black=LCD_COLOR_SELECT;
			
			}
			else
			{
				Colour.black=LCD_COLOR_TEST_BACK;
			}
			if(Jk516save.Sys_Setvalue.lanage)
			{
					pt=Test_Speedvalue_E;
			
			}
			else
			{
					pt=Test_Speedvalue;
			
			}
			LCD_DrawFullRect( DISPX1, FIRSTLINE+HIGH1,RECT , HIGH1  ) ;	
			WriteString_16(DISPX1+16, FIRSTLINE+HIGH1, pt[Jk516save.Set_Data.speed],  0);
		
		
			//电阻比较	
			Black_Select=(keynum==3)?1:0;
			if(Black_Select)
			{
				Colour.black=LCD_COLOR_SELECT;
			
			}
			else
			{
				Colour.black=LCD_COLOR_TEST_BACK;
			}
			if(Jk516save.Sys_Setvalue.lanage)
			{
					pt=Test_Compvalue_E;
			
			}
			else
			{
					pt=Test_Compvalue;
			}
			
			LCD_DrawFullRect( DISPX1, FIRSTLINE+HIGH1*3,RECT , HIGH1  ) ;
		WriteString_16(DISPX1, FIRSTLINE+HIGH1*3, pt[Jk516save.Set_Data.Res_comp],  0);
		
		
	   //电阻下限	
		Black_Select=(keynum==4)?1:0;
		if(Black_Select)
		{
			Colour.black = LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black = LCD_COLOR_TEST_BACK;
		}
		
		
		Hex_Format(Jk516save.Set_Data.Res_low.Num , Jk516save.Set_Data.Res_low.Dot , 6 , 0);
		LCD_DrawFullRect( DISPX1 , FIRSTLINE+HIGH1*4-6, RECT, HIGH1  ) ;
		LCD_DispString_EN_CH(DISPX1, FIRSTLINE+HIGH1*4-6, DispBuf);
		WriteString_16(DISPX1+16*7, FIRSTLINE+HIGH1*4+8-6,DISP_UINT[Jk516save.Set_Data.Res_low.Unit],  0);

	
  //电压比较	
	Black_Select=(keynum==5)?1:0;
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
    if(Jk516save.Sys_Setvalue.lanage)
    {
        pt=Test_Compvalue_E;
    
    }
    else
    {
        pt=Test_Compvalue;
    
    }
	LCD_DrawFullRect( DISPX1, FIRSTLINE+HIGH1*6,RECT-16, HIGH1  ) ;
	WriteString_16(DISPX1, FIRSTLINE+HIGH1*6, pt[Jk516save.Set_Data.V_comp],  0);
	//电压下限
	Black_Select=(keynum==6)?1:0;
	
	
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
	
	Hex_Format(Jk516save.Set_Data.V_low.Num , Jk516save.Set_Data.V_low.Dot , 6 , 0);
	LCD_DrawFullRect( DISPX1, FIRSTLINE+HIGH1*7-6,RECT, HIGH1  ) ;
	LCD_DispString_EN_CH(DISPX1, FIRSTLINE+HIGH1*7-6, DispBuf);
	WriteString_16(DISPX1+16*8, FIRSTLINE+HIGH1*7+8-6, "V",  0);
	

//量程
	Black_Select=(keynum==7)?1:0;
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
    if(Jk516save.Sys_Setvalue.lanage)
    {
        ppt=User_Range_E;
    
    }
    else
    {
        ppt=User_Range;
    
    }
    LCD_DrawFullRect( DISPX2, FIRSTLINE,RECT , HIGH1  ) ;
    if(Jk516save.Set_Data.Range_Set==0)
        
        WriteString_16(DISPX2+16, FIRSTLINE, ppt[0],  0);//待改
    else
        WriteString_16(DISPX2+16, FIRSTLINE, ppt[Jk516save.Set_Data.Range+1],  0);//待改
	
//讯响
	Black_Select=(keynum==8)?1:0;
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
     if(Jk516save.Sys_Setvalue.lanage)
    {
        pt=Setup_Beep_E;
    
    }
    else
    {
        pt=Setup_Beep;
    
    }
	LCD_DrawFullRect( DISPX2, FIRSTLINE+HIGH1,RECT , HIGH1  ) ;
	WriteString_16(DISPX2+16, FIRSTLINE+HIGH1, pt[Jk516save.Set_Data.beep],  0);
	
	//电阻标称
	Black_Select=(keynum==9)?1:0;
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
	
	
	Hex_Format(Jk516save.Set_Data.Nominal_Res.Num , Jk516save.Set_Data.Nominal_Res.Dot , 6 , 0);
	LCD_DrawFullRect( DISPX2, FIRSTLINE-2+HIGH1*3-6,RECT, HIGH1  ) ;
	LCD_DispString_EN_CH(DISPX2, FIRSTLINE+HIGH1*3-6, DispBuf);
  WriteString_16(DISPX2+16*7, FIRSTLINE+HIGH1*3+8-6, DISP_UINT[Jk516save.Set_Data.Nominal_Res.Unit],  0);


//电阻上限
	
	Black_Select=(keynum==10)?1:0;
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
	
	Hex_Format(Jk516save.Set_Data.High_Res.Num , Jk516save.Set_Data.High_Res.Dot , 6 , 0);
	LCD_DrawFullRect( DISPX2, FIRSTLINE+HIGH1*4-6,RECT, HIGH1 ) ;
	LCD_DispString_EN_CH(DISPX2, FIRSTLINE+HIGH1*4-6, DispBuf);
	WriteString_16(DISPX2+16*7, FIRSTLINE+HIGH1*4+8-6,DISP_UINT[Jk516save.Set_Data.High_Res.Unit],  0);
		
	
//电压标称
	
	Black_Select=(keynum==11)?1:0;
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
	
	Hex_Format(Jk516save.Set_Data.Nominal_V.Num, Jk516save.Set_Data.Nominal_V.Dot ,6 , 0);
	LCD_DrawFullRect( DISPX2, FIRSTLINE+HIGH1*6-6, RECT , HIGH1) ;
	LCD_DispString_EN_CH(DISPX2, FIRSTLINE+HIGH1*6-6, DispBuf);
	
	WriteString_16(DISPX2+16*8, FIRSTLINE+HIGH1*6+8-6, "V",  0);
	
	
//电压上限
	
	Black_Select=(keynum==12)?1:0;
	if(Black_Select)
	{
		Colour.black=LCD_COLOR_SELECT;
	
	}
	else
	{
		Colour.black=LCD_COLOR_TEST_BACK;
	}
	
	
	Hex_Format(Jk516save.Set_Data.V_high.Num, Jk516save.Set_Data.V_high.Dot , 6 , 0);
	LCD_DrawFullRect( DISPX2, FIRSTLINE+HIGH1*7-6,RECT , HIGH1) ;
	LCD_DispString_EN_CH(DISPX2, FIRSTLINE+HIGH1*7-6, DispBuf);
	
	WriteString_16(DISPX2+16*8, FIRSTLINE+HIGH1*7+8-6, "V",  0);
	
	Disp_Fastbutton();
	
	Colour.Fword=LCD_COLOR_BUTTON;
	
	switch(keynum)
	{
		case 0:
				Disp_Button_value1(0);
			break;
		case 1:
			
				Colour.black=LCD_COLOR_TEST_BUTON;
                if(Jk516save.Sys_Setvalue.lanage)
                {
                    pt=Test_Tirpvalue_E;
                
                }
                else
                {
                    pt=Test_Tirpvalue;
                
                }
				for(i=0;i<2;i++)
					WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			
		break;
		case 2:

			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=Test_Speedvalue_E;
            
            }
            else
            {
                pt=Test_Speedvalue;
            
            }
			for(i=0;i<4;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
		break;
		case 3:
			
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=Test_Compvalue_E;
            
            }
            else
            {
                pt=Test_Compvalue;
            
            }
			for(i=0;i<2;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 4:
			
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=INPUT_E;
            
            }
            else
            {
                pt=INPUT;
            
            }
			for(i=0;i<1;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 5:
			
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=Test_Compvalue_E;
            
            }
            else
            {
                pt=Test_Compvalue;
            
            }
			for(i=0;i<2;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 6:
			
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=INPUT_E;
            
            }
            else
            {
                pt=INPUT;
            
            }
			for(i=0;i<1;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 7:
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                ppt=User_Rangeset;
            
            }
            else
            {
                ppt=User_Rangeset;
            
            }
			for(i=0;i<5;i++)
			{
				
				WriteString_16(8+i*BUTTON_W, BUTTON_1+16, ppt[i],  0);
			}
			break;
		case 8:
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=Setup_Beep_E;
            
            }
            else
            {
                pt=Setup_Beep;
            
            }
			for(i=0;i<3;i++)
			{
				
				WriteString_16(16+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 9:
			//Colour.Fword=White;
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=INPUT_E;
            
            }
            else
            {
                pt=INPUT;
            
            }
			for(i=0;i<1;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 10:
			//Colour.Fword=White;
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=INPUT_E;
            
            }
            else
            {
                pt=INPUT;
            
            }
			for(i=0;i<1;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 11:
			//Colour.Fword=White;
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=INPUT_E;
            
            }
            else
            {
                pt=INPUT;
            
            }
			for(i=0;i<1;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		case 12:
			//Colour.Fword=White;
			Colour.black=LCD_COLOR_TEST_BUTON;
            if(Jk516save.Sys_Setvalue.lanage)
            {
                pt=INPUT_E;
            
            }
            else
            {
                pt=INPUT;
            
            }
			for(i=0;i<1;i++)
			{
				
				WriteString_16(SPACE1+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
			}
			break;
		
			
		default:
			break;
		
			
	
	
	}

}
void Disp_Sys_Screen(void)
{
	Disp_TopBar_Color();
	Disp_Fastbutton();//显示快速按键	  
//	Disp_ListScan_MidRect();//显示中间色块	 User_LimitList_Item  
}
//系统设置子函数
void Disp_SysLine(void)
{
 	uint32_t i;
	for(i=0;i<7;i++)
	{
			LCD_DrawFullRect( 90, FIRSTLINE+(i+1)*SPACE1-2, 100,1);
	}

}
void Disp_Sys_Item(void)
{
		uint32_t i;
    const u8 (*pt)[sizeof(Sys_Setitem[0])];
    const u8 (*ppt)[sizeof(All_TopName[0])];
		Disp_Sys_Screen();
		Colour.Fword = White;
		Colour.black = LCD_COLOR_TEST_BAR;
    if(Jk516save.Sys_Setvalue.lanage)
        ppt=All_TopName_E;
    else
        ppt=All_TopName;
		
		WriteString_16(0, 4, ppt[8],  0);
		
		Colour.Fword = LCD_COLOR_SET;
		Colour.black = LCD_COLOR_TEST_BACK;
    if(Jk516save.Sys_Setvalue.lanage)
        pt = Sys_Setitem_E;
    else
        pt = Sys_Setitem;
		for(i=0;i<(sizeof(Sys_Setitem)/(sizeof(Sys_Setitem[0])));i++)
		{
			 WriteString_16(LIST1, FIRSTLINE+( HIGH1+8 )*i, pt[i],  0);
		}

}

//显示设置参数的值Setup_Valueall
void Disp_Sys_value(u8 keynum)
{

		vu32 i;
    const u8 (*pt)[7];
		vu32 Black_Select;
		Colour.Fword = LCD_COLOR_YELLOW;
    RTC_TimeTypeDef RTC_TimeStructure;
		RTC_DateTypeDef RTC_DateStructure;
    RTC_TimeStructure.RTC_H12 = RTC_HourFormat_24;
	
		//串口开关
		Black_Select = ( keynum==1 ) ? 1 : 0;
		if(Black_Select)
			  Colour.black = LCD_COLOR_SELECT;
		else
			  Colour.black = LCD_COLOR_TEST_BACK;
		if(Jk516save.Sys_Setvalue.lanage)
				pt = Test_Compvalue_E;
		else
				pt = Test_Compvalue;

		LCD_DrawFullRect( DISPX1+10, FIRSTLINE, RECT, HIGH1 );
		LCD_DispString_MS24x23( DISPX1+10, FIRSTLINE, pt[Jk516save.Sys_Setvalue.uart]);
		
	  //波特率
		Black_Select = (keynum == 2) ? 1 : 0;
		if(Black_Select)
				Colour.black = LCD_COLOR_SELECT;
		else
				Colour.black = LCD_COLOR_TEST_BACK;
		LCD_DrawFullRect( DISPX1+10, FIRSTLINE+HIGH1, RECT, HIGH1) ;
		LCD_DispString_EN_CH(DISPX1+10, FIRSTLINE+HIGH1, Sys_Buard_Value[Jk516save.Sys_Setvalue.buard]);
		
		//U盘开关
		Black_Select = ( keynum == 3 ) ? 1 : 0;
		if(Black_Select)
				Colour.black = LCD_COLOR_SELECT;
		else
				Colour.black = LCD_COLOR_TEST_BACK;
		if(Jk516save.Sys_Setvalue.lanage)
				pt=Test_Compvalue_E;
		else
				pt=Test_Compvalue;
		LCD_DrawFullRect( DISPX1+10, FIRSTLINE+( HIGH1+8 )*2, RECT, HIGH1) ;
		WriteString_16( DISPX1+10, FIRSTLINE+( HIGH1+8 )*2, pt[Jk516save.Sys_Setvalue.u_flag],  0);
		
		//IO接口开关
		Black_Select = ( keynum == 4 ) ? 1 : 0;
		if(Black_Select)
				Colour.black = LCD_COLOR_SELECT;
		else
				Colour.black = LCD_COLOR_TEST_BACK;
		if(Jk516save.Sys_Setvalue.lanage)
				pt=Test_Compvalue_E;
		else
				pt=Test_Compvalue;	
		LCD_DrawFullRect( DISPX1+10, FIRSTLINE+( HIGH1+8 )*3, RECT, HIGH1) ;
		WriteString_16( DISPX1+10, FIRSTLINE+( HIGH1+8 )*3, pt[Jk516save.Sys_Setvalue.plc],  0);
		
	  //显示语言
		Black_Select = ( keynum == 5 ) ? 1 : 0;
		if(Black_Select)
				Colour.black = LCD_COLOR_SELECT;
		else
				Colour.black = LCD_COLOR_TEST_BACK;	
		LCD_DrawFullRect( DISPX1+10, FIRSTLINE+( HIGH1+8 )*4, RECT, HIGH1) ;//SPACE1
		WriteString_16( DISPX1+10, FIRSTLINE+( HIGH1+8 )*4, Sys_Language_Value[Jk516save.Sys_Setvalue.lanage],  0);
		RTC_GetTime( RTC_Format_BIN, &RTC_TimeStructure);
		RTC_GetDate( RTC_Format_BIN, &RTC_DateStructure);
	
		//年
		Black_Select = ( keynum == 6 ) ? 1 : 0;
		if(Black_Select)
		{
			Colour.black = LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black = LCD_COLOR_TEST_BACK;
		}
		LCD_DrawFullRect( DISPX1+10, FIRSTLINE+( HIGH1+8 )*5 -5, 32, HIGH1) ;

		sprintf((char *)DispBuf,"%02d",RTC_DateStructure.RTC_Year);
		LCD_DispString_EN_CH( DISPX1+10, FIRSTLINE+( HIGH1+8 )*5-5, DispBuf);
		Colour.black = LCD_COLOR_TEST_BACK;
		LCD_DispString_EN_CH( DISPX1+32+10, FIRSTLINE+( HIGH1+8 )*5-5, "-");
		
		//月
		Black_Select = (keynum==7)?1:0;
		if(Black_Select)
		{
			Colour.black=LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black = LCD_COLOR_TEST_BACK;
		}
		LCD_DrawFullRect( DISPX1+48+10, FIRSTLINE+( HIGH1+8 )*5-5,32 , HIGH1 ) ;//SPACE1

		sprintf((char *)DispBuf,"%02d",RTC_DateStructure.RTC_Month);
		LCD_DispString_EN_CH(DISPX1+48+10, FIRSTLINE+( HIGH1+8 )*5-5, DispBuf);
		Colour.black=LCD_COLOR_TEST_BACK;
		LCD_DispString_EN_CH( DISPX1+80+10, FIRSTLINE+( HIGH1+8 )*5-5, "-");
		
		
		//日
		Black_Select=(keynum==8)?1:0;
		if(Black_Select)
		{
			Colour.black=LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black=LCD_COLOR_TEST_BACK;
		}
		
		LCD_DrawFullRect( DISPX1+96+10, FIRSTLINE+( HIGH1+8 )*5-5,32 ,HIGH1 ) ;//SPACE1

		sprintf((char *)DispBuf,"%02d",RTC_DateStructure.RTC_Date);
		LCD_DispString_EN_CH(DISPX1+96+10, FIRSTLINE+( HIGH1+8 )*5-5, DispBuf);

		//时
		Black_Select=(keynum==9)?1:0;
		if(Black_Select)
		{
			Colour.black=LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black=LCD_COLOR_TEST_BACK;
		}
		LCD_DrawFullRect( DISPX1+10, FIRSTLINE+( HIGH1+8 )*6-5,32 , HIGH1 ) ;//SPACE1

		sprintf((char *)DispBuf,"%02d",RTC_TimeStructure.RTC_Hours);
		LCD_DispString_EN_CH(DISPX1+10, FIRSTLINE+( HIGH1+8 )*6-5, DispBuf);
		Colour.black=LCD_COLOR_TEST_BACK;
		LCD_DispString_EN_CH(DISPX1+32+10, FIRSTLINE+( HIGH1+8 )*6-5, ":");
	
		//分
		Black_Select=(keynum==10)?1:0;
		if(Black_Select)
		{
			Colour.black=LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black=LCD_COLOR_TEST_BACK;
		}
		LCD_DrawFullRect( DISPX1+16*3+10, FIRSTLINE+( HIGH1+8 )*6-5,32 , HIGH1 ) ;//SPACE1

		sprintf((char *)DispBuf,"%02d",RTC_TimeStructure.RTC_Minutes);
		LCD_DispString_EN_CH(DISPX1+48+10, FIRSTLINE+( HIGH1+8 )*6-5, DispBuf);
		Colour.black=LCD_COLOR_TEST_BACK;
		LCD_DispString_EN_CH(DISPX1+80+10, FIRSTLINE+( HIGH1+8 )*6-5, ":");
		
		
		//秒
		Black_Select=(keynum==11)?1:0;
		if(Black_Select)
		{
			Colour.black=LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black=LCD_COLOR_TEST_BACK;
		}
		LCD_DrawFullRect( DISPX1+96+10, FIRSTLINE+( HIGH1+8 )*6-5,32 ,HIGH1 ) ;//SPACE1
		sprintf((char *)DispBuf,"%02d",RTC_TimeStructure.RTC_Seconds);
		LCD_DispString_EN_CH(DISPX1+96+10, FIRSTLINE+( HIGH1+8 )*6-5, DispBuf);
		
		//文件名称
		Black_Select=(keynum==12)?1:0;
		if(Black_Select)
		{
			Colour.black=LCD_COLOR_SELECT;
		
		}
		else
		{
			Colour.black=LCD_COLOR_TEST_BACK;
		}
			
		LCD_DrawFullRect( DISPX1+10, FIRSTLINE+( HIGH1+8 )*7,RECT ,HIGH1) ;//SPACE1
		WriteString_16(DISPX1+10, FIRSTLINE+( HIGH1+8 )*7,(const uint8_t *) Jk516save.Sys_Setvalue.textname,  0);

			
		Disp_Fastbutton();
		Colour.Fword=LCD_COLOR_BUTTON;
		Colour.black=LCD_COLOR_TEST_BUTON;
		switch(keynum)
		{
			case 0:
					Disp_Button_SysSet();
				break;
			case 1:
							if(Jk516save.Sys_Setvalue.lanage)
							{
									pt=Test_Compvalue_E;
							
							}
							else
							{
									pt=Test_Compvalue;
							
							}
							for(i=0;i<2;i++)
							WriteString_16(25+i*BUTTON_W, BUTTON_1+16, pt[i],  0);


			break;
			case 2:
				for(i=0;i<5;i++)
				{
					
					WriteString_16(16+i*BUTTON_W, BUTTON_1+16, Sys_Buard_Value[i],  0);
				}
			break;
			case 3:
				if(Jk516save.Sys_Setvalue.lanage)
							{
									pt=Test_Compvalue_E;
							
							}
							else
							{
									pt=Test_Compvalue;
							
							}
				for(i=0;i<2;i++)
				{
					
					WriteString_16(25+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
				}
				break;
			case 4:
					if(Jk516save.Sys_Setvalue.lanage)
					{
							pt=Test_Compvalue_E;
								
					}
					else
					{
							pt=Test_Compvalue;
								
					}
					for(i=0;i<2;i++)
					{
						
						WriteString_16(25+i*BUTTON_W, BUTTON_1+16, pt[i],  0);
					}
				break;
			case 5:
					WriteString_16(16+0*BUTTON_W, BUTTON_1+16, Sys_Language_Button[0],  0);
					WriteString_16(4+1*BUTTON_W, BUTTON_1+16, Sys_Language_Button[1],  0);
				break;
			case 6:
			case 7:
			case 8:
			case 9:							
			case 10:							
			case 11:
				for(i=0;i<2;i++)
				{
					
					WriteString_16(8+i*BUTTON_W, BUTTON_1+16, BiasButton_Tip[i],  0);
				}
				break;
		  default:
				break;
		
		}

}



void Disp_Sys(void)
{
	  uint32_t i;
    const u8 (*pt)[(sizeof(Sys_Sys[0]))];
    const u8 (*ppt)[(sizeof(All_TopName[0]))];
		Disp_Sys_Screen();
		Colour.Fword = White;
		Colour.black = LCD_COLOR_TEST_BAR;
    if( Jk516save.Sys_Setvalue.lanage )
        ppt = All_TopName_E;
    else
        ppt = All_TopName;
		WriteString_16( 0, 4, ppt[10],  0);
		Colour.Fword = Green;
		Colour.black=LCD_COLOR_TEST_BACK;
    if(Jk516save.Sys_Setvalue.lanage)
        pt=Sys_Sys_E;
    else
        pt=Sys_Sys;

		for(i=0;i<(sizeof(Sys_Sys)/(sizeof(Sys_Sys[0])));i++)
		{
			WriteString_16( LIST1 , FIRSTLINE+(SPACE1+10)*i, pt[i],  0);

		}
    LCD_DispString_EN_CH(LIST1+32*7-10, FIRSTLINE+(SPACE1+10)*3-8, (const uint8_t*)Jk516save.fac_num);

		Disp_Button_SysSet();
}

void Disp_button_Num_time(void)
{
		Disp_Fastbutton();
		
		Colour.black = LCD_COLOR_TEST_BUTON;
		Colour.Fword = LCD_COLOR_BUTTON;
		WriteString_16(32, BUTTON_1+16, "mΩ ",  0);
		WriteString_16(32+128,BUTTON_1+16, " Ω ",  0);

}

//数字键输入显示
Sort_TypeDef Disp_NumKeyboard_Set(Disp_Coordinates_Typedef *Coordinates,u8 flag )
{
    u8 lenth;
	vu8 While_flag=1;
	vu8 Disp_buff[10];
	vu8 key,i;
	vu8 dispflag=1;
	vu8 dot_num=0,dot_num1=0;
	vu32 keynum=0;
	vu8 key_count=0;
	Sort_TypeDef  Sort_set;
	Sort_set.Dot=0;
	Sort_set.Num=0;
	Sort_set.Unit=0;
	
	for(i=0;i<7;i++)
		Disp_buff[i]=' ';
	Disp_buff[7]=0;
	if(flag)
        lenth = NUM_LENTH_V;
    else
        lenth = NUM_LENTH;
	while( While_flag )
	{
		key = Key_Read_WithTimeOut(TICKS_PER_SEC_SOFTTIMER/10);
		if( key != KEY_NONE)
		{
			ButtonSound();
			dispflag=1;
			switch(key)
			{
				case Key_F1:
							
					Sort_set.Unit = 0;
							
					While_flag = 0;
					if( key_count < lenth )
					{
						if( dot_num == 0)
						{
							if( key_count > 0)
							{
								Disp_buff[key_count] = '.';
								dot_num1 = key_count;
								key_count++;
							}
							dot_num++;
						}
					}												
					Sort_set.Updata_flag = 1;
						
				break;
				
				case Key_F2:
								
					Sort_set.Unit=1;			
					While_flag=0;
					if(key_count<lenth)
					{
						if(dot_num==0)
						{
							if(key_count>0)
							{
								Disp_buff[key_count]='.';
								dot_num1=key_count;
								key_count++;
											
							}
							
							
							dot_num++;
						}
									
					}	
					Sort_set.Updata_flag=1;
						
				break;
				
				case Key_F3:				
				case Key_F4:
				case Key_F5:
						
				break;
				
				case Key_Disp:
					SetSystemStatus(SYS_STATUS_TEST);
					While_flag=0;
					Sort_set.Updata_flag=0;
					
				break;
				
				case Key_SETUP:
						While_flag=0;
						Sort_set.Updata_flag=0;
					SetSystemStatus(SYS_STATUS_SETUP);
				break;
				
				case Key_FAST:
				case Key_LEFT:
				case Key_RIGHT:
				case Key_UP:
				case Key_DOWN:
				break;
				
				case Key_NUM1:
					
					if(key_count<lenth - flag)
					{
						Disp_buff[key_count]='1';
						key_count++;
								
					}
				break;
				
				case Key_NUM2:
					if(key_count<lenth - flag)
					{
						Disp_buff[key_count]='2';
						key_count++;
					}
				break;
					
				case Key_NUM3:
					if(key_count<lenth - flag)
					{
						Disp_buff[key_count]='3';
						key_count++;
					}
				break;
					
				case Key_NUM4:
					if(key_count<lenth - flag)
					{
						Disp_buff[key_count]='4';
						key_count++;
					}
						
				break;
					case Key_NUM5:
						if(key_count<lenth - flag)
						{
							Disp_buff[key_count]='5';
							key_count++;
						}
					break;
					case Key_NUM6:
						if(key_count<lenth - flag)
						{
							Disp_buff[key_count]='6';
							key_count++;
						}
					break;
					case Key_NUM7:
						if(key_count<lenth - flag)
						{
							Disp_buff[key_count]='7';
							key_count++;
						}
					break;
					case Key_NUM8:
						if(key_count<lenth - flag)
						{
							Disp_buff[key_count]='8';
							key_count++;
						}
					break;
					case Key_NUM9:
						if(key_count<lenth - flag)
						{
							Disp_buff[key_count]='9';
							key_count++;
						}
					break;
					case Key_NUM0:
						if(key_count<lenth - flag)
						{
							Disp_buff[key_count]='0';
							key_count++;
						}
					break;
					case Key_DOT:
						
						if(key_count<lenth&&key_count>0)
						{
							if(dot_num==0)
							{
								if(key_count>0)
								{
									Disp_buff[key_count]='.';
									dot_num1=key_count;
									key_count++;
								
								
								}
								dot_num++;
							}
						}
					break;
					case Key_BACK:
						if(key_count>0)
						{	key_count--;
							Disp_buff[key_count]=' ';
							if(dot_num1==key_count)
							{
								dot_num=0;
								dot_num1=0;
								
							}
						
						}
						else
						{
							if(Disp_buff[key_count]==0)
									Disp_buff[key_count]='-';
								else if(Disp_buff[key_count]=='-')
									Disp_buff[key_count]='+';
								else
									Disp_buff[key_count]='-';
								key_count++;
						}
					break;
					case Key_LOCK:
					case Key_BIAS:
					case Key_REST:
					case Key_TRIG:
							break;
					default:
						break;
						
				}
		
			}
			if(dispflag)
			{
				dispflag = 0;
					
				Colour.Fword = 0X000000;
					
				Colour.black = 0x00FFFF;
					
				LCD_DrawFullRect( Coordinates->xpos, Coordinates->ypos, Coordinates->lenth, HIGH1  );
					
				LCD_DispString_EN_CH(Coordinates->xpos, Coordinates->ypos, (const uint8_t *)Disp_buff);
		
			}
	
		}
		for( i = key_count; i < lenth; i++)
				Disp_buff[i] = '0'; 
		for( i = 0; i < lenth; i++)
		{
				if( Disp_buff[0] >= '0' && ( Disp_buff[0] <= '9' ) )
				{
						if( Disp_buff[i] >= '0' && ( Disp_buff[i] <= '9' ) )
						{
								if( dot_num1 > i)
								{
										Sort_set.Num *= 10;
										Sort_set.Num += Disp_buff[i] - '0';
								
								}
								else
								{
										Sort_set.Num *= 10;
										Sort_set.Num += Disp_buff[i] - '0';
								}
						}
				}	
		}
		Sort_set.Dot = dot_num1;
		return Sort_set;

}


Sort_TypeDef Time_Set_Cov(Sort_TypeDef *Time)
{
	float value;
	int32_t temp = 1;
	int i;
	if(Time->Num>99999)
	{
		Time->Num/=10;
		Time->Dot=MAX_DOTNUM;
		
	}
	Time->Dot=MAX_DOTNUM-Time->Dot;
	value=Time->Num;
	if(Time->Unit==0)
		value*=(float)1e4;
	else if(Time->Unit==1)
		value*=(float)1e7;
  else if(Time->Unit==2)
		value*=(float)1e10;

	for( i = 0; i < Time->Dot; i++)
			temp *= 10;
	if( temp > (float)2e9)
	{
		temp = 2e9;
	
	}
  value /= temp; 
	
//	if(value>(float)3e7)
//	{
//		Time->Num=30000;
//		Time->Dot=4;
//		Time->Unit=1;
//	}
//  else if(value>=(float)3e9)
//	{
//		Time->Num=value/(float)1e5;
//		Time->Dot=4;
//		Time->Unit=2;
//	}
//	else if(value>=(float)3e8)
//	{
//		Time->Num=value/(float)1e4;
//		Time->Dot=2;
//		Time->Unit=1;
//	
//	
//	}else if(value>=(float)3e7)
//	{
//		Time->Num=value/(float)1e3;
//		Time->Dot=3;
//		Time->Unit=1;
//	}
//	else if(value>=(float)3e6)
//	{
//		Time->Num=value/(float)100;
//		Time->Dot=4;
//		Time->Unit=1;
//	
//	}else 
	if(value>=(float)1e7)
	{
		Time->Num=value/(float)1000;
		if(Time->Num > 30000)
		{
			Time->Num = 30000;
		}
		Time->Dot=4;
		Time->Unit=1;
		
	
	}
//	else if(value>=(float)1e5)
//	{
//		Time->Num=value/(float)10;
////		Time->Num=value;
//		Time->Dot=3;
//		Time->Unit=0;
//	
//	}
  else
  {
		Time->Num=value/(float)10;
		Time->Dot=3;
		Time->Unit=0;
	
	}
	Time->mid_data = value;
	return *Time;
}
//电阻设置
Sort_TypeDef Disp_Set_Num(Disp_Coordinates_Typedef *Coordinates)
{
	Sort_TypeDef Sort_num,Sort_num1;
	Disp_button_Num_time();
	Sort_num=Disp_NumKeyboard_Set(Coordinates,0);
	Sort_num1=Time_Set_Cov(&Sort_num);
	if(Sort_num1.Updata_flag==0)
	{
		Sort_num1.Dot=0;
		Sort_num1.Num=0;
		Sort_num1.Unit=0;
	
	}
		
	return Sort_num1;

}
Sort_TypeDef Input_Set_Cov(Sort_TypeDef *Input_Ref)//
{

	float value;
	int32_t _temp = 1;
	int i;
	value=(float)Input_Ref->Num*100000;
	for( i = 0; i < 7 - Input_Ref->Dot; i++)
			_temp *= 10;
	if( _temp > (float)2e9)
	{
		_temp = 2e9;
	
	}
	
	//value /=(pow(10,7 - Input_Ref->Dot) );
	value /=  _temp;
	
	if(value>60000)
	{
		value=60000;
		Input_Ref->Dot=3;
		Input_Ref->Num=value;
	}else{
		Input_Ref->Dot=3;
		Input_Ref->Num=value;
	}
//	if(value>=(float)1e5)
//	{
//		Input_Ref->Dot=2;
//		Input_Ref->Num=value/100;
//	
//	
//	}else if(value>=(float)1e4)
//	{
//		Input_Ref->Dot=3;
//		Input_Ref->Num=value;
//	
//	
//	}
//	else
//	{
//		Input_Ref->Dot=4;
//		Input_Ref->Num=value;
//	
//	
//	}
	Input_Ref->mid_data=value;
	return *Input_Ref;
}
void Disp_button_Num_Freq(void)
{
	
		Disp_Fastbutton();
		
		Colour.black = LCD_COLOR_TEST_BUTON;
		Colour.Fword = LCD_COLOR_BUTTON;
	
		WriteString_16(48, BUTTON_1+16, " V ",  0);

}
//电压设置
Sort_TypeDef Disp_Set_CompNum(Disp_Coordinates_Typedef *Coordinates)
{
  
    Sort_TypeDef Sort_num,Sort_num1;
		Disp_button_Num_Freq();
		Sort_num=Disp_NumKeyboard_Set(Coordinates,0);
		Sort_num1=Input_Set_Cov(&Sort_num);
		if(Sort_num1.Updata_flag==0)
		{
			Sort_num1.Dot=0;
			Sort_num1.Num=0;
			Sort_num1.Unit=0;
		
		}
		return Sort_num1;

}
void Disp_Range(u8 hand,u8 range)
{
    if(hand>1)
        hand=1;
    if(range>6)
        range=6;
	Colour.Fword = White;
    Colour.black = LCD_COLOR_TEST_BACK;
    LCD_DispString_MS24x23( LCD_WITH-200, 400-32, Range_Disp_Test[hand][range]);

}

void Swap(uint32_t A[], uint16_t i, uint16_t j)
{
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
//冒泡排序
void BubbleSort(uint32_t A[], uint16_t n)
{
    for (int j = 0; j < n - 1; j++)         // 每次最大元素就像气泡一样"浮"到数组的最后
    {
        for (int i = 0; i < n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移
        {
            if (A[i] > A[i + 1])            // 如果条件改成A[i] >= A[i + 1],则变为不稳定的排序算法
            {
                Swap(A, i, i + 1);
            }
        }
    }
}

uint8_t R_Comp(void)
{
   
		float testvalue;
    float set_highvalue;
    float set_lowvalue;
    u8 flag;
    testvalue=Test_Value.res * pow(10,3*(Test_Value.uint)) / pow(10,Test_Value.dot);
    set_highvalue=Jk516save.Set_Data.High_Res.Num * pow(10,3*(Jk516save.Set_Data.High_Res.Unit)) / pow(10,Jk516save.Set_Data.High_Res.Dot);
    set_lowvalue=Jk516save.Set_Data.Res_low.Num * pow(10,3*(Jk516save.Set_Data.Res_low.Unit)) / pow(10,Jk516save.Set_Data.Res_low.Dot);
    
		if(testvalue>set_highvalue)			//大于上限
        
				flag=1;
    else if(testvalue<set_lowvalue)	//小于下限
        flag=2;
    else
        flag=0;											//合格
    
		return flag;

}


uint8_t V_Comp(void)
{
    u32 testvalue;
    u32 set_highvalue;
    u32 set_lowvalue;
    u8 flag;
    u8 dot=1;
    if(Test_Value_V.dot==3)
        dot=10;
    testvalue=Test_Value_V.res*dot;
    
    if(Jk516save.Set_Data.V_high.Dot==3)
        set_highvalue=Jk516save.Set_Data.V_high.Num*10;
    else if(Jk516save.Set_Data.V_high.Dot==5)
        set_highvalue=Jk516save.Set_Data.V_high.Num/10;
    else
        set_highvalue=Jk516save.Set_Data.V_high.Num;
        
    
    if(Jk516save.Set_Data.V_low.Dot==3)
        set_lowvalue=Jk516save.Set_Data.V_low.Num*10;
    else if(Jk516save.Set_Data.V_low.Dot==5)
        set_lowvalue=Jk516save.Set_Data.V_low.Num/10;
    else
        set_lowvalue=Jk516save.Set_Data.V_low.Num;
    
    if(testvalue>set_highvalue)//大于上限
        flag=1;
    else if(testvalue<set_lowvalue)//小于下限
        flag=2;
    else
        flag=0;
    return flag;
}


uint8_t Jisuan_Range(Sort_TypeDef date)//0  m  1    2 k
{
    uint8_t range;
    if(date.Dot==3&&date.Unit==0)
        range=0;
    if(date.Dot==2&&date.Unit==0)
        range=1;
    if(date.Dot==4&&date.Unit==1)
        range=2;
    if(date.Dot==3&&date.Unit==1)
        range=3;
    if(date.Dot==2&&date.Unit==1)
        range=4;
    if(date.Dot==4&&date.Unit==2)
        range=5;
    if(date.Dot==3&&date.Unit==2)
        range=6;
    
    return range;


}
uint8_t Jisuan_V_Range(Sort_TypeDef date)
{
    uint8_t range;
    if(date.Dot==3&&date .Num>120000)
        range=1;
    else
        range=0;

    return range;
}

//显示时间
void Disp_dateandtime(void)
{
    
    RTC_TimeTypeDef RTC_TimeStructure;
	  RTC_DateTypeDef RTC_DateStructure;
    char LCDTemp[30];
	
    RTC_GetTime(RTC_Format_BIN, &RTC_TimeStructure);  //改1秒扫描一次
    RTC_GetDate(RTC_Format_BIN, &RTC_DateStructure);

	  sprintf(LCDTemp," %0.2d:%0.2d:%0.2d", 
    RTC_TimeStructure.RTC_Hours, 
    RTC_TimeStructure.RTC_Minutes,
    RTC_TimeStructure.RTC_Seconds);
	
	usbreadtime[0] = (u8)((2000 + RTC_DateStructure.RTC_Year) >> 8);//年高位
	usbreadtime[1] = (u8)(RTC_DateStructure.RTC_Year);//年低位
	usbreadtime[2] = (u8)(RTC_DateStructure.RTC_Month);//月
	usbreadtime[3] = (u8)(RTC_DateStructure.RTC_Date);//日
	usbreadtime[4] = (u8)(RTC_TimeStructure.RTC_Hours);//时
	usbreadtime[5] = (u8)(RTC_TimeStructure.RTC_Minutes);//分
	usbreadtime[6] = (u8)(RTC_TimeStructure.RTC_Seconds);//秒
    Colour.black = LCD_COLOR_TEST_BACK;
    LCD_DispString_EN_CH( LIST2+150, LIST1+3, (const uint8_t *)LCDTemp );
	
    memcpy((void*)Send_To_U.No, LCDTemp, 9);
    Send_To_U.No[19] = 9;

}

void Disp_Debug_Reference( vu8 list,Test_ValueTypedef eee,Test_ValueTypedef ddd)
{
		
		if(list)
			if(list>DEBUG_RANGE-2)
				 
					Hex_Format(eee.res,eee.dot,6,FALSE);
			else
					
					Hex_Format(ddd.res,ddd.dot,7,FALSE);
		WriteString_16(LIST1+160+160, FIRSTLINE+(SPACE1-2)*(list), DispBuf,  1);


}
const vu8 Debug_Dot[DEBUG_RANGE]={3,2,1,3,4,3};


//显示设置参数的值Setup_Valueall
void Disp_Debug_value(vu8 list)
{
		vu32 i;
		vu32 Black_Select;
		for(i=0;i<DEBUG_RANGE;i++)
		{
			if(list==(i+1))
			{
				Colour.black=LCD_COLOR_SELECT;
			
			}
			else
			{
				Colour.black=LCD_COLOR_TEST_BACK;
			}
		
		
			LCD_DrawFullRect( LIST1+160, FIRSTLINE+(SPACE1-2)*(i+1),90 , SPACE1-2 ) ; //SPACE1
			
			Hex_Format(Jk516cal.Debug_Value[i].standard, Debug_Dot[i] , 6 , 0); //sprintf((char *)DispBuf,"%4",Save_Res;
			
			WriteString_16(LIST1+160, FIRSTLINE+(SPACE1-2)*(i+1), DispBuf,  1);
				
		}
		Colour.black=LCD_COLOR_TEST_BACK;

}
//用户校正界面子函数
void Disp_Usercheck_Screen(void)
{
	Disp_TopBar_Color();
	Disp_Fastbutton(); 

}


void Disp_UserCheck_Item(void)
{
	uint32_t i;
	Disp_Usercheck_Screen();
	Colour.Fword = White;
	Colour.black = LCD_COLOR_TEST_BAR;
	WriteString_16( 0, 4, All_TopName[5],  0);
	Colour.Fword=White;
	Colour.black=LCD_COLOR_TEST_BACK;
	
	for(i=0;i<(sizeof(User_Check_main)/(sizeof(User_Check_main[0])));i++)
	{
		WriteString_16(LIST1+160*i, FIRSTLINE, User_Check_main[i],  0);

	}
	
	for(i=0;i<(sizeof(User_Check_Item)/(sizeof(User_Check_Item[0])));i++)
	{
		WriteString_16(LIST1, FIRSTLINE+(SPACE1-2)*(i+1), User_Check_Item[i],  0);

	}

}
int32_t Debug_Valuedata(Sort_TypeDef *Debug_value)
{
    if(Debug_value->Num>10000)
        Debug_value->Num/=10;
		return Debug_value->Num;

}

int32_t Debug_ValuedataV(Sort_TypeDef *Debug_value)
{
		return Debug_value->Num;

}

vu32 Debug_Set_Num(Disp_Coordinates_Typedef *Coordinates)
{
	Sort_TypeDef Sort_num;
	vu32 num;
	Disp_button_Num_Freq();
	Sort_num=Disp_NumKeyboard_Set(Coordinates,1);
	num = Debug_ValuedataV(&Sort_num);
	return num;
	
}
vu32 Debug_Set_Res(Disp_Coordinates_Typedef *Coordinates)
{
    Sort_TypeDef Sort_num;
    vu32 num; 
    Disp_button_Num_time();
    Sort_num=Disp_NumKeyboard_Set(Coordinates,0);
    num= Debug_Valuedata(&Sort_num);
    return num; 

}
void Debug_stanedcomp(void)
{
    vu8 i;
   for(i=0;i<DEBUG_RANGE;i++)
    {
        if(Jk516cal.Debug_Value[i].standard>Debug_Compvalue[i][1]||Jk516cal.Debug_Value[i].standard<Debug_Compvalue[i][1])
        {
            if(i<DEBUG_RANGE-2)
            {
                
                 Jk516cal.Debug_Value[i].standard=1000;
                    
                
            }
            else
            {
            
                Jk516cal.Debug_Value[i].standard=60000;
            
            }
        }
            
    
    }


}
//输入仪器编号
void input_num(Disp_Coordinates_Typedef *Coordinates )
{
  	char While_flag=1;
		uint8_t Disp_buff[12];
		uint8_t  key,i;
		char dispflag=1;

		char key_count=0;

	
		for(i=0;i<8;i++)
				Disp_buff[i]=' ';
	
		Disp_buff[8]=0;
    Disp_buff[9]=0;
    
	
	while(While_flag)
	{
		key=Key_Read_WithTimeOut(TICKS_PER_SEC_SOFTTIMER/10);
		
		if(key!=KEY_NONE)
		{
			dispflag=1;
			switch(key)
			{
				case Key_F1://退出
					 
                       //SetSystemStatus(SYS_STATUS_USERDEBUG);

					
				break;
				case Key_F2://取消
                    
					
				break;
				case Key_F3://确认保存机号和日期

					
				break;
				case Key_F4:
					
				break;
				case Key_F5:
                   //return  &Disp_buff[0];
					
				break;
				case Key_Disp:

				break;
				case Key_SETUP:

				break;
				case Key_FAST:
                    While_flag=0;//保存
                    dispflag=0;
                    for(i=0;i<9;i++)
                    {
                        Jk516save.fac_num[i]=Disp_buff[i];
                    
                    }
                    Store_set_flash();
                    LCD_DrawFullRect( 0, Coordinates->ypos-20,200 , Coordinates->ypos+20 );//待查
				break;
				case Key_LEFT:
				break;
				case Key_RIGHT:
				break;
				case Key_UP:
				break;
				case Key_DOWN:
				break;
				case Key_NUM1:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='1';
						key_count++;
							
					}
				break;
				case Key_NUM2:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='2';
						key_count++;
					}
				break;
				case Key_NUM3:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='3';
						key_count++;
					}
				break;
				case Key_NUM4:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='4';
						key_count++;
					}
					
				break;
				case Key_NUM5:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='5';
						key_count++;
					}
				break;
				case Key_NUM6:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='6';
						key_count++;
					}
				break;
				case Key_NUM7:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='7';
						key_count++;
					}
				break;
				case Key_NUM8:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='8';
						key_count++;
					}
				break;
				case Key_NUM9:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='9';
						key_count++;
					}
				break;
				case Key_NUM0:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='0';
						key_count++;
					}
				break;
				case Key_DOT:
                    if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='/';
						key_count++;
					}
					

				break;
				case Key_BACK:
					if(key_count)
					{	key_count--;
						Disp_buff[key_count]=' ';

					
					}

				break;
				case Key_LOCK:
				break;
				case Key_BIAS:
				break;
				case Key_REST:
				break;
				case Key_TRIG:
				break;
				default:
				break;
					
			}
		}
		if(dispflag)
		{
				dispflag=0;
        Colour.Fword=Red;
        LCD_DrawLine( Coordinates->xpos+13+80, Coordinates->ypos-2, 80, 0  );
        LCD_DrawLine( Coordinates->xpos+13+80, Coordinates->ypos+18, 80,0 );
        for(i=0;i<9;i++)
					LCD_DrawLine( Coordinates->xpos+13+i*10, Coordinates->ypos-2+20, 20, 1  );
            
				Colour.Fword=White;
				Colour.black=LCD_COLOR_TEST_BACK;
        WriteString_16(Coordinates->xpos-70, Coordinates->ypos, "出厂编号:",  0);
				WriteString_16(Coordinates->xpos+13, Coordinates->ypos, ( uint8_t *)Disp_buff,  0);
        WriteString_16(Coordinates->xpos, Coordinates->ypos-20, "请输入8位出厂编号",  0);
		}
	
	}

}

void input_password(Disp_Coordinates_Typedef *Coordinates )
{
  	char While_flag=1;
	char Disp_buff[10];
	u8 key,i;
	char dispflag=1;
	char dot_num=0,dot_num1=0;
    char password_flag=0;
	char  key_count=0;
	for(i=0;i<9;i++)
	Disp_buff[i]=0;
	Disp_Button_value1(2);
	while(While_flag)
	{
		key=Key_Read_WithTimeOut(TICKS_PER_SEC_SOFTTIMER/10);
		if(key!=KEY_NONE)
		{
            //Key_Beep()
            password_flag=0;
//            Key_Beep();
			dispflag=1;
			switch(key)
			{
				case Key_F1://退出
					 While_flag=0;
                       SetSystemStatus(SYS_STATUS_TEST);

					
				break;
				case Key_F3://取消
                    
					
				break;
				case Key_F2://确认
                   if(strcmp(PASSWORD,Disp_buff))//比较函数  当相等时  返回0
                   {//密码错误
                       key_count=0;
                       for(i=0;i<8;i++)
                        Disp_buff[i]=' ';
                       password_flag=1;
                       
                   
                   
                   }
                   else //密码正确
                   {
                        While_flag=0;
                       SetSystemStatus(SYS_STATUS_DEBUG);
                   
                   }
                       
					
				break;
				case Key_F4:
					
				break;
				case Key_F5:
					
				break;
				case Key_Disp:
//					SetSystemStatus(SYS_STATUS_TEST);
//					While_flag=0;
//					Sort_set.Updata_flag=0;
				break;
				case Key_SETUP:
//					While_flag=0;
//					Sort_set.Updata_flag=0;
//				SetSystemStatus(SYS_STATUS_SETUPTEST);
				break;
				case Key_FAST:
				break;
				case Key_LEFT:
				break;
				case Key_RIGHT:
				break;
				case Key_UP:
				break;
				case Key_DOWN:
				break;
				case Key_NUM1:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='1';
						
						
							
						
						key_count++;
							
					}
				break;
				case Key_NUM2:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='2';
						key_count++;
					}
				break;
				case Key_NUM3:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='3';
						key_count++;
					}
				break;
				case Key_NUM4:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='4';
						key_count++;
					}
					
				break;
				case Key_NUM5:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='5';
						key_count++;
					}
				break;
				case Key_NUM6:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='6';
						key_count++;
					}
				break;
				case Key_NUM7:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='7';
						key_count++;
					}
				break;
				case Key_NUM8:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='8';
						key_count++;
					}
				break;
				case Key_NUM9:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='9';
						key_count++;
					}
				break;
				case Key_NUM0:
					if(key_count<PASSWORD_LENTH)
					{
						Disp_buff[key_count]='0';
						key_count++;
					}
				break;
				case Key_DOT:
					
					if(key_count<PASSWORD_LENTH&&key_count>0)
					{
						if(dot_num==0)
						{
							if(key_count>0)
							{
								Disp_buff[key_count]='.';
								dot_num1=key_count;
								key_count++;
							
							
							}
							dot_num++;
						}
					}
//					else 
//					{
//						if(Disp_buff[key_count]==0)
//							Disp_buff[key_count]='-';
//						else if(Disp_buff[key_count]=='-')
//							Disp_buff[key_count]='+';
//						else
//							Disp_buff[key_count]='-';
//						key_count++;
//							
//					
//					
//					
//					
//					}
				break;
				case Key_BACK:
					if(key_count>0)
					{	key_count--;
						Disp_buff[key_count]=' ';
						if(dot_num1==key_count)
						{
							dot_num=0;
							dot_num1=0;
							
						}
					
					}
					else
					{
						if(Disp_buff[key_count]==0)
								Disp_buff[key_count]='-';
							else if(Disp_buff[key_count]=='-')
								Disp_buff[key_count]='+';
							else
								Disp_buff[key_count]='-';
							key_count++;
					}
				break;
				case Key_LOCK:
				break;
				case Key_BIAS:
				break;
				case Key_REST:
				break;
				case Key_TRIG:
				break;
				default:
				break;
					
			}
		
		
		}
		if(dispflag)
		{
			dispflag=0;
            Colour.Fword=Red;
//            LCD_DrawLine( Coordinates->xpos+13+80, Coordinates->ypos-2, 80, 0);
//            LCD_DrawLine( Coordinates->xpos+13+80, Coordinates->ypos+18, 80, 0  );
//            for(i=0;i<9;i++)
//            LCD_DrawLine( Coordinates->xpos+13+i*10, Coordinates->ypos-2+20, 20, 1 );
            
			//LCD_DrawRect( Coordinates->xpos, Coordinates->ypos,Coordinates->xpos+Coordinates->lenth , Coordinates->ypos+16 , Red );
			Colour.Fword=White;
			Colour.black=LCD_COLOR_TEST_BACK;
            WriteString_16(Coordinates->xpos-38, Coordinates->ypos, "密码:",  0);
			WriteString_16(Coordinates->xpos+38, Coordinates->ypos, ( uint8_t *)Disp_buff,  0);
            if(password_flag)
                WriteString_16(Coordinates->xpos, Coordinates->ypos+20, "密码错误",  0);
            else
//               LCD_DrawFullRect( Coordinates->xpos, Coordinates->ypos+20,100 ,40);
               // WriteString_16(Coordinates->xpos, Coordinates->ypos, "         ",  0);
            WriteString_16(Coordinates->xpos, Coordinates->ypos-40, "输入8位密码",  0);
			//dispflag=0;
		}
	
	}

}

void bubble_sort_better(u32 a[],int n)//n为数组a的元素个数
{
    //最多进行N-1轮比较
    for(int i=0; i<n-1; i++)
    {
        u8 isSorted = 1;
        //每一轮比较前n-1-i个，即已排序好的最后i个不用比较
        for(int j=0; j<n-1-i; j++)
        {
            if(a[j] > a[j+1])
            {
                isSorted = 0;
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1]=temp;
            }
        }
        if(isSorted) break; //如果没有发生交换，说明数组已经排序好了
    }
}


u8 read_adI_1(void)
{
    u16 i;

    for(i=0;i<500;i++)
    {
        while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
       scan_I[i]= Read_Convert_read();

        if(scan_I[i]>0x800000)
        {
            scan_I[i]=0xffffff-scan_I[i];
           
        }
    }
		bubble_sort_better(scan_I,500);
		disp_I=0;
		for(i=1;i<500;i++)
		{
			disp_I+=scan_I[i];
		
		
		}
		disp_I/=499;
		disp_I/=720;
		return 1;
   
}


u8 read_adV_1(void)
{
    u16 i;
    for( i = 0;i < 300; i++)
    {
        while( GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7) == Bit_RESET );
        scan_V[i] = Read_Convert_read();
        if(scan_V[i] > 0x800000)
        {
            scan_V[i] = 0xffffff-scan_V[i];
						polarity_v = 0;
        }
				else
					polarity_v = 1;

    }	
		bubble_sort_better(scan_V,300);
		disp_V = 0;
		for( i = 1; i < 300; i++)
				disp_V += scan_V[i];
		
		disp_V /= 299;
		disp_V /= 8;
		return 1;
  

}

u8 read_adI_2(void)
{
    u16 i;

    for(i=0;i<400;i++)
    {
        while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
       scan_I[i]= Read_Convert_read();

        if(scan_I[i]>0x800000)
        {
            scan_I[i]=0xffffff-scan_I[i];
           
        }
    }
		bubble_sort_better(scan_I,400);
		disp_I=0;
		for(i=1;i<400;i++)
		{
			disp_I+=scan_I[i];
		
		
		}
		disp_I/=399;
		disp_I/=720;
		return 1;
   
}


u8 read_adV_2(void)
{
    u16 i;
    for( i = 0;i < 300; i++)
    {
        while( GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7) == Bit_RESET );
        scan_V[i] = Read_Convert_read();
        if(scan_V[i] > 0x800000)
        {
            scan_V[i] = 0xffffff-scan_V[i];
						polarity_v = 0;
        }
				else
					polarity_v = 1;

    }
		bubble_sort_better(scan_V,200);
		disp_V = 0;
		for( i = 1; i < 200; i++)
				disp_V += scan_V[i];
		
		disp_V /= 199;
		disp_V /= 80;
		return 1;
  

}

u8 read_adI_3(void)
{
    u16 i;

    for(i=0;i<200;i++)
    {
        while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
       scan_I[i]= Read_Convert_read();

        if(scan_I[i]>0x800000)
        {
            scan_I[i]=0xffffff-scan_I[i];
           
        }
    }
		bubble_sort_better(scan_I,200);
		disp_I=0;
		for(i=1;i<200;i++)
		{
			disp_I+=scan_I[i];
		
		
		}
		disp_I/=199;
		disp_I/=720;
		return 1;
   
}


u8 read_adV_3(void)
{
    u16 i;
    for( i = 0;i < 100; i++)
    {
        while( GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7) == Bit_RESET );
        scan_V[i] = Read_Convert_read();
        if(scan_V[i] > 0x800000)
        {
            scan_V[i] = 0xffffff-scan_V[i];
						polarity_v = 0;
        }
				else
					polarity_v = 1;

    }
		bubble_sort_better(scan_V,100);
		disp_V = 0;
		for( i = 1; i < 100; i++)
				disp_V += scan_V[i];
		
		disp_V /= 99;
		disp_V /= 80;
		return 1;
  

}

u8 read_adI_4(void)
{
    u16 i;

    for(i=0;i<50;i++)
    {
        while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
       scan_I[i]= Read_Convert_read();

        if(scan_I[i]>0x800000)
        {
            scan_I[i]=0xffffff-scan_I[i];
           
        }
    }
		bubble_sort_better(scan_I,50);
		disp_I=0;
		for(i=1;i<50;i++)
		{
			disp_I+=scan_I[i];
		
		
		}
		disp_I/=49;
		disp_I/=720;
		return 1;
   
}


u8 read_adV_4(void)
{
    u16 i;
    for( i = 0;i < 50; i++)
    {
        while( GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7) == Bit_RESET );
        scan_V[i] = Read_Convert_read();
        if(scan_V[i] > 0x800000)
        {
            scan_V[i] = 0xffffff-scan_V[i];
						polarity_v = 0;
        }
				else
					polarity_v = 1;

    }
		bubble_sort_better(scan_V,100);
		disp_V = 0;
		for( i = 1; i < 50; i++)
				disp_V += scan_V[i];
		
		disp_V /= 49;
		disp_V /= 80;
		return 1;
  

}


void read_adV_one(void)
{
	V_ad=0;
//	
//	u16 i;
//    for( i = 0;i < 5; i++)
//    {
//        while( GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7) == Bit_RESET );
//        scan_V[i] = Read_Convert_read();
//        if(scan_V[i] > 0x800000)
//        {
//            scan_V[i] = 0xffffff-scan_V[i];
//						polarity_v = 0;
//        }
//				else
//					polarity_v = 1;

//    }
//		bubble_sort_better(scan_V,100);
//		for( i = 1; i < 4; i++)
//				V_ad += scan_V[i];
//		
//		V_ad /= 3;
	
    while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_SET);
    delay_us(20);
	while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
	V_ad= Read_Convert_read();   
}

void read_adI_one(void)
{
	
//	u16 i;
	I_ad=0;
//    for(i=0;i<5;i++)
//    {
//        while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
//       scan_I[i]= Read_Convert_read();

//        if(scan_I[i]>0x800000)
//        {
//            scan_I[i]=0xffffff-scan_I[i];
//           
//        }
//    }
//		bubble_sort_better(scan_I,5);
//		for(i=1;i<4;i++)
//		{
//			I_ad+=scan_I[i];
//		}
//		I_ad/=3;
	
    while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_SET);
    delay_us(20);
	while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
	I_ad= Read_Convert_read();   
}


//void read_adI_3(void)
//{
//    u8 i;
//    I_ad=0;
//    for(i=0;i<100;i++)
//    {
//        while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
//       scan_I[i]= Read_Convert_read();
//        if(i>2)
//        if(scan_I[i]>0x800000)
//        {
//            scan_I[i]=0xffffff-scan_I[i];
//            I_ad-=scan_I[i];
//        }
//        else
//            I_ad+=scan_I[i];
//            
//        
//    }
//    I_ad/=98;
//}
//void read_adV_3(void)
//{
//    u8 i;
//    V_ad=0;
//    delay_1us(20);
//    for(i=0;i<50;i++)
//    {
//        while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
//       scan_V[i]= Read_Convert_read();
//        if(i>2)
//        if(scan_V[i]>0x800000)
//        {
//            scan_V[i]=0xffffff-scan_V[i];
//            V_ad-=scan_V[i];
//        }
//        else
//            V_ad+=scan_V[i];
//    }
//    V_ad/=48;
//}
//void read_adI_2(void)
//{
//    u8 i,j;
//    u32 buff[5];
//    I_ad=0;
//    for(j=0;j<5;j++)
//    {
//        for(i=0;i<100;i++)
//        {
//            while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
//                scan_I[i]= Read_Convert_read();
//            if(i>2)
//            if(scan_I[i]>0x800000)
//            {
//                scan_I[i]=0xffffff-scan_I[i];
//                I_ad-=scan_I[i];
//            }
//            else
//                I_ad+=scan_I[i];
//                
//            
//        }
//        I_ad/=98;
//        buff[j]=I_ad;
//        
//    }
//    I_ad=0;
//    for(i=1;i<5;i++)
//    {
//        I_ad+=buff[i];
//    
//    
//    }
//    I_ad/=4;
//    //Select_V_I(0);
//}
//void read_adV_2(void)
//{
//    u8 i,j;
//    u32 buff[5];
//    V_ad=0;
//    delay_1us(20);
//    for(j=0;j<5;j++)
//    {
//        for(i=0;i<100;i++)
//        {
//            while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
//           scan_V[i]= Read_Convert_read();
//            if(i>2)
//            if(scan_V[i]>0x800000)
//            {
//                scan_V[i]=0xffffff-scan_V[i];
//                V_ad-=scan_V[i];
//            }
//            else
//                V_ad+=scan_V[i];
//        }
//        V_ad/=98;
//        buff[j]=V_ad;
//    }
//    V_ad=0;
//    for(i=0;i<5;i++)
//    {
//        V_ad+=buff[i];
//    
//    
//    }
//    V_ad/=5;
//}

//void read_adI_1(void)
//{
//    u8 i,j;
//    float buff[10];
//    I_ad=0;
//    for(j=0;j<10;j++)
//    {
//        for(i=0;i<10;i++)
//        {
//            while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
//                scan_I[i]= Read_Convert_read();
//            if(i>2)
//            if(scan_I[i]>0x800000)
//            {
//                scan_I[i]=0xffffff-scan_I[i];
//                I_ad-=scan_I[i];
//            }
//            else
//                I_ad+=scan_I[i];
//                
//            
//        }
//        I_ad/=10;
//        
//        buff[j]=I_ad;
//        
//    }
//    I_ad=0;
//    for(i=1;i<10;i++)
//    {
//        I_ad+=buff[i];
//    
//    
//    }
//    I_ad/=9;
//    
//}
//void read_adV_1(void)
//{
//    u8 i,j;
//    float buff[10];
//    V_ad=0;
//    delay_1us(20);
//    for(j=0;j<10;j++)
//    {
//        for(i=0;i<100;i++)
//        {
//            while(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_7)==Bit_RESET);
//           scan_V[i]= Read_Convert_read();
//            if(i>2)
//            if(scan_V[i]>0x800000)
//            {
//                scan_V[i]=0xffffff-scan_V[i];
//                V_ad-=scan_V[i];
//            }
//            else
//                V_ad+=scan_V[i];
//        }
//        V_ad/=98;
//        buff[j]=V_ad;
//    }
//    V_ad=0;
//    for(i=0;i<10;i++)
//    {
//        V_ad+=buff[i];
//    
//    
//    }
//    V_ad/=10;
//    
//}

void lvbo_jisu(void)
{
    if(V_ad>0x800000)
    {
        V_ad=V_ad-0xffffff;
    }
    if(I_ad>0x800000)
    {
        I_ad=I_ad-0xffffff;
        
    }


}
void lvbo_pingjun(void)
{
    uint16_t i;
    Ad_value=0;
    V_ad=0;
    I_ad=0;
    BubbleSort(scan_V, fit_allnum[Jk516save.Set_Data.speed]);
    for(i=fit_allnum[Jk516save.Set_Data.speed]/4;
    i<fit_allnum[Jk516save.Set_Data.speed]-fit_allnum[Jk516save.Set_Data.speed]/4;i++)
    {
        if(scan_V[i]>0x800000)
        {
            scan_V[i]=0xffffff-scan_V[i];
            V_ad-=scan_V[i];
        }
        else
        {
            V_ad+=scan_V[i];
        
        }
        
    }
    V_ad/=fit_allnum[Jk516save.Set_Data.speed]/2;
    BubbleSort(scan_I, fit_allnum[Jk516save.Set_Data.speed]);
    for(i=fit_allnum[Jk516save.Set_Data.speed]/4;
    i<fit_allnum[Jk516save.Set_Data.speed]-fit_allnum[Jk516save.Set_Data.speed]/4;i++)
    {
        if(scan_I[i]>0x800000)
        {
            scan_I[i]=0xffffff-scan_I[i];
            I_ad-=scan_I[i];
            
        }
        else
        {
            I_ad+=scan_I[i];
        
        }
        
    }
    I_ad/=fit_allnum[Jk516save.Set_Data.speed]/2;
                    
                   

}
void Soft_Turnon(void)
{

		Power_On_led();

		All_LedOff();
		Beep_Off();
    delay_ms(1000);
    delay_ms(1000);
    EXTI_ClearITPendingBit(KEY1_INT_EXTI_LINE);
		NVIC_EnableIRQ(EXTI3_IRQn);    
    //
		while(GetSystemStatus()==SYS_STATUS_TOOL)
		{
		

	
	
		}
		NVIC_DisableIRQ(EXTI3_IRQn);
		Power_Off_led();

}

void DispBattery(void)
{
	LCD_SetColors(LCD_COLOR_WHITE,LCD_COLOR_TEST_BACK);
	LCD_DrawUniLine(500-48-80,10,500-48-80,30);
	LCD_DrawUniLine(500-48-80,10,540-48-80,10);
	LCD_DrawUniLine(500-48-80,30,540-48-80,30);
	LCD_DrawUniLine(540-48-80,10,540-48-80,15);
	LCD_DrawUniLine(540-48-80,15,545-48-80,15);
	LCD_DrawUniLine(545-48-80,15,545-48-80,25);
	LCD_DrawUniLine(540-48-80,25,545-48-80,25);
	LCD_DrawUniLine(540-48-80,25,540-48-80,30);
	if(GPIO_ReadInputDataBit(BATCAP_PORT4,BATCAP_PIN4))
	{
		Colour.Fword = LCD_COLOR_GREEN;
		Colour.black = LCD_COLOR_GREEN;
	}else{
		Colour.Fword = LCD_COLOR_TEST_BACK;
		Colour.black = LCD_COLOR_TEST_BACK;
	}
	LCD_DrawFullRect(395-20,12,7,17);
	
	if(GPIO_ReadInputDataBit(BATCAP_PORT3,BATCAP_PIN3))
	{
		Colour.Fword = LCD_COLOR_GREEN;
		Colour.black = LCD_COLOR_GREEN;
	}else{
		Colour.Fword = LCD_COLOR_TEST_BACK;
		Colour.black = LCD_COLOR_TEST_BACK;
	}
	LCD_DrawFullRect(395+9-20,12,7,17);
	
	if(GPIO_ReadInputDataBit(BATCAP_PORT2,BATCAP_PIN2))
	{
		Colour.Fword = LCD_COLOR_GREEN;
		Colour.black = LCD_COLOR_GREEN;
	}else{
		Colour.Fword = LCD_COLOR_TEST_BACK;
		Colour.black = LCD_COLOR_TEST_BACK;
	}
	LCD_DrawFullRect(395+18-20,12,7,17);
	
	if(GPIO_ReadInputDataBit(BATCAP_PORT1,BATCAP_PIN1))
	{
		Colour.Fword = LCD_COLOR_GREEN;
		Colour.black = LCD_COLOR_GREEN;
	}else{
		Colour.Fword = LCD_COLOR_TEST_BACK;
		Colour.black = LCD_COLOR_TEST_BACK;
	}
	LCD_DrawFullRect(395+27-20,12,7,17);
	
}

//(x-100)/0.385  Pt100的计算公式  X是电阻值
/********************************
函数名称: void DispF(float f)
功能 ：用科学记数法显示浮点数，在float全范围内精确显示，超出范围给出提示。
说明 ：浮点数表示范围为+-1.175494E-38到+-3.402823E+38
入口参数：f为要显示的浮点数
返回值 ：无
********************************/

//（2）显示十进制尾数和阶的子函数。
/********************************
函数名称: void PrintW(unsigned long w,char j)
功能 ：科学记数法，显示十进制尾数和阶码
入口参数：w为尾数，j为阶码
返回值 ：无
********************************/

//==========================================================
//END
//==========================================================




